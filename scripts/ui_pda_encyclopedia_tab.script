---------------------------------
----- Written by Darryl123 ------
---------------------------------

-------------------------
----- Miscellaneous -----
-------------------------

-- Initialises (if necessary) and returns the encyclopedia interface.
-- Used by pda.script and dxr_encyclopedia.script.
local SINGLETON = nil
function get_ui()
	SINGLETON = SINGLETON or pda_encyclopedia_tab()
	return SINGLETON
end

------------------------
----- Constructors -----
------------------------

-- Encyclopedia interface.
class "pda_encyclopedia_tab" (CUIScriptWnd)
function pda_encyclopedia_tab:__init() super()
	-- Tables.
	self.categories = {}
	self.interactivity = {}
	self.locked_articles = {}
	
	-- Plugin init.
	self:InitPlugin()
	self:InitPlugin2()
	
	-- Interface init.
	self:InitControls()
	self:InitCallbacks()
	self:InitCategories()
end

-- Finalize.
function pda_encyclopedia_tab:__finalize()
	SINGLETON = nil 
end

-- Article and category items.
class "pda_encyclopedia_entry" (CUIListBoxItem)
function pda_encyclopedia_entry:__init() super(22)
	self.sect = self:GetTextItem()
	self.sect:SetWndRect(Frect():set(0, 0, 300, 22))
	self:SetTextColor(GetARGB(255, 216, 186, 140))
	self.sect:SetFont(GetFontLetterica18Russian())
	self.sect:SetWndSize(vector2():set(400, 22))
	self.sect:SetEllipsis(true)
end

---------------------
----- Callbacks -----
---------------------

-- Called when an article is selected.
function pda_encyclopedia_tab:SelectArticle(index1, index2)
	-- GetSelectedIndex() starts counting at 0.
	index1 = index1 or (self.category_list:GetSelectedIndex() + 1)
	index2 = index2 or (self.article_list:GetSelectedIndex() + 1)
	
	-- Calls to this method may require a forced index change.
	self.category_list:SetSelectedIndex(index1 - 1)
	self.article_list:SetSelectedIndex(index2 - 1)
	
	-- Establish the section of the article selected.
	local category = self.categories[index1]
	local section = category and category.articles[index2] or nil
	if not (section) then return end
	
	-- Set the article's text.
	self.information:SetText(game.translate_string(section .. "_text"))
	
	-- Hide the article if it isn't unlocked.
	local display_image = true
	for k, v in pairs (self.locked_articles) do
		if (section == v) then
			self.information:SetText(game.translate_string("pda_btn_encyclopedia_locked"))
			display_image = nil
			break
		end
	end
	
	-- Set the interface component sizes.
	self.information:AdjustHeightToText()
	self.information:SetWndSize(vector2():set(self.information:GetWidth(), self.information:GetHeight() + 7))
	
	-- Set the article's image.
	-- A bit hacky, but to allow for dynamic width/height we have to initialise the texture twice.
	-- We load the texture, grab its dimensions, set the window size then reinitialise it a second time.
	-- If we don't do this then for whatever weird and wonderful reason the image refuses to draw on the UI.
	-- The coefficient_x variable is used to fix image stretchiness when using widescreen resolutions.
	self.image:InitTexture(section .. "_image")
	
	-- Grab the dimensions of the image and the x coefficient.
	local image_width = self.image:GetTextureRect().x2 - self.image:GetTextureRect().x1
	local image_height = self.image:GetTextureRect().y2 - self.image:GetTextureRect().y1
	local coefficient_x = (device().height / device().width) / (768 / 1204)
	
	-- Resize the image and container, and then reinitialise the texture.
	self.image_container:SetWndSize(vector2():set(image_width, image_height + 20))
	self.image:SetWndSize(vector2():set(image_width * coefficient_x, image_height))
	self.image:SetStretchTexture(true)
	self.image:InitTexture(section .. "_image")
	
	-- Clear the scrollbar and add the text and image container.
	self.scrollbar:Clear()
	self.scrollbar:AddWindow(self.information, true)
	if (display_image) then
		self.scrollbar:AddWindow(self.image_container, true)
	end
	
	-- Prevent components from being deleted while used.
	self.information:SetAutoDelete(false)
	self.image_container:SetAutoDelete(false)
	self.image:SetAutoDelete(false)
end

-- Called when a category is selected.
function pda_encyclopedia_tab:SelectCategory(index)
	-- GetSelectedIndex() starts counting at 0.
	index = index or (self.category_list:GetSelectedIndex() + 1)
	self.category_list:SetSelectedIndex(index - 1)
	
	-- Initialise the category's articles.
	local category = self.categories[index]
	self:InitArticles(category)
end

--------------------------
----- Initialisation -----
--------------------------

-- Add all of the required articles to a list box.
-- Called when selecting a category, do not call via constructor.
function pda_encyclopedia_tab:InitArticles(category)
	-- Blank the article list before changing category.
	self.article_list:RemoveAll()
	
	-- Return if the articles table cannot be retrieved.
	local articles = category and category.articles or nil
	if not (articles) then return end
	
	local item = nil
	local section = nil
	for i = 1, #articles do
		item = pda_encyclopedia_entry()
		section = articles[i]
		if (section) then
			item.sect:SetText(game.translate_string(section))
			-- Hide the article's title if it isn't unlocked.
			for k, v in pairs(self.locked_articles) do
				if (v == section) then
					item.sect:SetText("??????????")
					break
				end
			end
			self.article_list:AddExistingItem(item)
		end
	end
end

-- Add the callbacks for the article and category lists.
function pda_encyclopedia_tab:InitCallbacks()
	self:AddCallback("article_list", ui_events.WINDOW_LBUTTON_DB_CLICK, self.SelectArticle, self)
	self:AddCallback("category_list", ui_events.WINDOW_LBUTTON_DB_CLICK, self.SelectCategory, self)
end

-- Add all of the required categories to a list box.
function pda_encyclopedia_tab:InitCategories()
	local item = nil
	local section = nil
	self.category_list:RemoveAll()
	for i = 1, #self.categories do
		item = pda_encyclopedia_entry()
		section = self.categories[i].section
		if (section) then
			item.sect:SetText(game.translate_string(section))
			self.category_list:AddExistingItem(item)
		end
	end
end

-- Create the interface.
function pda_encyclopedia_tab:InitControls()
	local xml = CScriptXmlInit()
	xml:ParseFile("pda_encyclopedia.xml")
	
	-- Main frame.
	self:SetWndRect(Frect():set(0, 0, 1024, 768))
	xml:InitFrame("frame1", self)
	xml:InitFrame("frame2", self)
	xml:InitFrame("border", self)
	xml:InitStatic("frame1:caption", self)
	
	-- Article and category lists.
	self.article_list = xml:InitListBox("article_list", self)
	self:Register(self.article_list, "article_list")
	self.category_list = xml:InitListBox("category_list", self)
	self:Register(self.category_list, "category_list")
	
	-- Text information, footer image (and container), and the scrollbar.
	self.information = xml:InitTextWnd("description:information", nil)
	self.image_container = xml:InitStatic("description:image_container", nil)
	self.image = xml:InitStatic("description:image_container:image", self.image_container)
	self.scrollbar = xml:InitScrollView("description:scrollbar", self)
	
	-- Add components to the scrollbar.
	self.scrollbar:AddWindow(self.information, true)
	self.scrollbar:AddWindow(self.image_container, true)
	
	-- Prevent components being deleted while used.
	self.information:SetAutoDelete(false)
	self.image_container:SetAutoDelete(false)
	self.image:SetAutoDelete(false)
end

-- Load the encyclopedia categories and articles.
function pda_encyclopedia_tab:InitPlugin()
	local ini = ini_file("plugins\\encyclopedia.ltx")
	
	-- Return if the encyclopedia plugin does not exist.
	local plugin_section = "encyclopedia"
	if not (ini:section_exist(plugin_section)) then
		printf("Encyclopedia section \"" .. plugin_section .. "\" does not exist.")
		return
	end
	
	-- Create a table for each encyclopedia category.
	local line_count = ini:line_count(plugin_section) or 0
	for i = 0, line_count - 1 do
		local junk1, section, junk2 = ini:r_line(plugin_section, i, "", "")
		self.categories[i + 1] = { section = section }
	end
	
	-- Fill each of the tables with their articles.
	local unlocked_articles = xr_statistic.actor_statistic.guide_articles
	for i = 1, #self.categories do
		if (ini:section_exist(self.categories[i].section)) then
			line_count = ini:line_count(self.categories[i].section) or 0
			self.categories[i].articles = {}
			for k = 0, line_count - 1 do
				local junk1, section, value = ini:r_line(self.categories[i].section, k, "", "")
				-- Unlocked articles table must exist, and must not contain this article.
				if (unlocked_articles and not unlocked_articles[section]) then
					-- Article must not have "unlocked" tag.
					if not (value == "unlocked") then
						table.insert(self.locked_articles, section)
					end
				end
				table.insert(self.categories[i].articles, section)
				
				-- Keep any unlocked articles permanently unlocked.
				-- When a counter is added to the interface this will make things simpler.
				if (value == "unlocked") then
					unlocked_articles[section] = true
				end
			end
		else printf("Encyclopedia category \"" .. self.categories[i].section .. "\" does not exist.") end
	end
end

-- Load the match-lists for interacting with in-game entities.
function pda_encyclopedia_tab:InitPlugin2()
	local ini = ini_file("plugins\\encyclopedia_interactivity.ltx")
	
	-- Return if the encyclopedia interactivity plugin does not exist.
	local plugin_section = "encyclopedia_interactivity"
	if not (ini:section_exist(plugin_section)) then
		printf("Encyclopedia interactivity section \"" .. plugin_section .. "\" does not exist.")
		return
	end
	
	-- Create a match-list of each key with a section.
	local plugin_sections = {}
	local line_count = ini:line_count(plugin_section) or 0
	for i = 0, line_count - 1 do
		local junk1, section, value = ini:r_line(plugin_section, i, "", "")
		plugin_sections[section] = value
	end
	
	-- Create a table for each key, and fill it with its contents.
	for match_key, match_section in pairs (plugin_sections) do
		self.interactivity[match_key] = {}
		line_count = ini:line_count(match_section) or 0
		for i = 0, line_count - 1 do
			local junk1, section, value = ini:r_line(match_section, i, "", "")
			self.interactivity[match_key][section] = value
		end
	end
end