-- axr_debug_tools UI script
-- Alundaio
--[[
Copyright (C) 2012 Alundaio
This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License-]]
--]]
UI_ICON_EQUIPMENT_WIDTH = 1024 
UI_ICON_EQUIPMENT_HEIGHT = 2048

id_to_spawn_table = {
		[1] = "Ammo",
		[2] = "Artefacts",
		[3] = "Items (Consumable)",
		[4] = "Items (Misc.)",
		[5] = "Items (Quest)",
		[6] = "NPC (Mutant)",				
		[7] = "NPC (Stalker)",				
		[8] = "Outfits",
		[9] = "Physic (Misc.)",				
		[10] = "Squads (Mutant)",			
		[11] = "Squads (Stalker)",			
		[12] = "Weapons (Addon)",
		[13] = "Weapons (Misc.)",
		[14] = "Weapons (Pistol)",
		[15] = "Weapons (Rifle)",
		[16] = "Vehicles",
		[17] = "Anomaly",
		[18] = "Phantom"
}

function get_spawn_table(name)
	if (name == "Phantom") then 
		return {
			"m_phantom_bloodsucker",
			"m_phantom_tushkano",
			"m_phantom_controller",
			"m_phantom_zombi",
			"m_phantom_snork",
			"m_phantom_boar",
			"m_phantom_flesh",
			"m_phantom_dog",
			"m_phantom_pseudodog",
			"m_phantom_cat"
		}
	elseif (name == "Anomaly") then 
		return {
				"zone_mine_gravitational_weak",
				"zone_mine_thermal_weak",
				"zone_mine_acidic_weak",
				"zone_mine_electric_weak",
				"zone_field_radioactive_weak",
				"zone_mine_steam_weak",
				"zone_field_psychic_weak",
				--"fireball_zone",
				--"fireball_electric_zone",
				--"fireball_acidic_zone",
				"zone_mine_field",
				"zone_mine_field_soc",
				"zone_no_gravity",
				"zone_teleport"
		}
	elseif (name == "Artefacts") then
		return {
				"af_medusa", 		    -- 1
				"af_cristall_flower",   -- 2
				"af_night_star", 	    -- 3
				"af_vyvert", 		    -- 4
				"af_gravi", 		    -- 5
				"af_gold_fish", 	    -- 6
				"af_cristall", 		    -- 7
				"af_fireball", 	        -- 8
				"af_dummy_glassbeads",  -- 9
				"af_eye", 			    -- 10
				"af_fire", 			    -- 11
				"af_blood", 		    -- 12
				"af_mincer_meat", 	    -- 13
				"af_soul", 			    -- 14
				"af_fuzz_kolobok", 	    -- 15
				"af_baloon", 		    -- 16
				"af_glass", 		    -- 17
				"af_electra_sparkler",  -- 18
				"af_electra_flash",     -- 19
				"af_electra_moonlight", -- 20
				"af_dummy_battery", 	-- 21
				"af_dummy_dummy", 		-- 22
				"af_ice", 				-- 23
				"af_compass", 			-- 24
				"af_oasis_heart", 		-- 25
				"jup_b1_half_artifact", -- 26
				"af_quest_b14_twisted", -- 27
				"af_drops",				-- 28
				"af_ameba_slime", 		-- 29
				"af_ameba_slug",		-- 30
				"af_ameba_mica",		-- 31
				"af_dummy_spring",		-- 32
				"af_dummy_pellicle",	-- 33
				"af_rusty_thorn",		-- 34
				"af_rusty_kristall", 	-- 35
				"af_rusty_sea",	-- 36
				}
	elseif (name == "Outfits") then
		return {
				"helm_respirator",
				"helm_hardhat",
				"helm_protective",
				"helm_tactic",
				"helm_battle",
				"helm_respirator_joker",
				"helm_hardhat_snag",
				"helm_m40",
				
				--Freedom
				"svoboda_novice_outfit",
				"svoboda_light_outfit",
				"svoboda_heavy_outfit",
				"svoboda_heavy_outfit_2",
				"svoboda_exo_outfit",
				"svoboda_scientific_outfit",
				
				--Ecolog
				"ecolog_outfit_green",
				"ecolog_outfit_orange",
				"scientific_outfit",
				"ecolog_guard_outfit",
				
				--Stalker
				"novice_outfit",
				"stalker_outfit",
				"stalker_outfit_barge",
				"exo_outfit",
				"radiation_outfit",
				"nbc_outfit",
				
				--Bandit
				"bandit_novice_outfit",
				"banditmerc_outfit",
				"trenchcoat_outfit",
				"bandit_exo_outfit",
				
				-- Duty
				"dolg_novice_outfit",
				"dolg_outfit",
				"dolg_heavy_outfit",
				"dolg_exo_outfit",
				"dolg_scientific_outfit",
				
				-- Army
				"military_outfit",
				"specops_outfit",
				"military_exo_outfit",
				"military_novice_outfit",
				
				-- Clear Sky
				"cs_novice_outfit",
				"cs_light_outfit",
				"cs_medium_outfit",
				"cs_heavy_outfit",
				"cs_light_novice_outfit",
				
				-- Mercenary
				"merc_outfit",
				"merc_exo_outfit",
				"merc_scientific_outfit",
				"merc_novice_outfit",

				-- Monolith
				"monolith_outfit",
				"monolith_scientific_outfit",
				"monolith_exo_outfit",
				"monolith_novice_outfit",
				
				"god_outfit"
				}
	elseif (name == "Items (Misc.)") then
		return {
				"mutant_part_krovosos_jaw",
				"mutant_part_boar_leg",
				"mutant_part_chimera_kogot",
				"mutant_part_chimera_claw",
				"mutant_part_dog_tail",
				"mutant_part_flesh_eye",
				"mutant_part_psevdodog_tail",
				"mutant_part_snork_leg",
				"mutant_part_tushkano_head",
				"mutant_part_pseudogigant_hand",
				"mutant_part_pseudogigant_eye",
				"mutant_part_controller_glass",
				"mutant_part_controller_hand",
				"mutant_part_burer_hand",
				"mutant_part_cat_tail",
				"mutant_part_fracture_hand",
				"mutant_part_zombi_hand",
				"device_torch",
				"detector_simple",
				"detector_advanced",
				"detector_elite",
				"detector_scientific",
				"itm_actor_backpack",
				"itm_backpack",
				"test_container",
				"itm_sleepbag",
				"itm_pda_common",
				"itm_pda_uncommon",
				"itm_pda_rare",
				"itm_gunsmith_toolkit",
				"itm_outfit_toolkit_tier_1",
				"itm_repairkit_tier_1",
				"itm_repairkit_tier_2",
				"itm_repairkit_tier_3",
				"stalker_patch",
				"ecolog_patch",
				"duty_patch",
				"merc_patch",
				"freedom_patch",
				"bandit_patch",
				"army_patch",
				"monolith_patch",
				"csky_patch"
				}
	elseif (name == "Items (Consumable)") then
		return {
				"bandage",
				"antirad",
				"medkit",
				"medkit_army",
				"medkit_scientic",

				"drug_booster",
				"drug_coagulant",
				"drug_psy_blockade",
				"drug_antidot",
				"drug_radioprotector",
				"drug_anabiotic",

				"bread",
				"kolbasa",
				"conserva",
				"vodka",
				"energy_drink"
				}
	elseif (name == "Weapons (Addon)") then
		return {
				"pso",
				"acog",
				"eot",
				"c-more",
				"ekp",
				"1p29",
				"ac11090",
				"pu",
				"addons_box",
				"wpn_addon_silencer10",
				"wpn_addon_silencer45",
				"wpn_addon_silencer50",
				"wpn_addon_silencer545",
				"wpn_addon_silencer556",
				"wpn_addon_silencer68",
				"wpn_addon_silencer762",
				"wpn_addon_silencer9x39",
				"wpn_addon_silencer12",
				"wpn_addon_silencer",
				"wpn_addon_grenade_launcher",
				"wpn_addon_grenade_launcher_m203",
				"wpn_addon_grenade_launcher_ag36"
				}
	elseif (name == "Weapons (Pistol)") then
		return  {
				"wpn_aps",
				"wpn_beretta",
				"wpn_desert_eagle",
				"wpn_desert_eagle_nimble",
				"wpn_pm",
				"wpn_pm_actor",
				"wpn_pb",
				"wpn_fort",
				"wpn_fort_snag",
				"wpn_hpsa",
				"wpn_walther",
				"wpn_sig220",
				"wpn_sig220_nimble",
				"wpn_colt1911",
				"wpn_usp",
				"wpn_usp_nimble",
				"wpn_mp412",
				"wpn_pmm",
				"wpn_coltde",
				"wpn_colt1911_sk2",
				"wpn_colt1911_sk3",
				"wpn_glock17",
				"wpn_glock21",
				"wpn_glock20",
				"wpn_glock35",
				"wpn_usp40",
				"wpn_usp10",
				"wpn_hpsa40",
				"wpn_beretta96",
				"wpn_walther40",
				"wpn_fnp45",
				"wpn_fnp40",
				"wpn_gsh18",
				"wpn_mp443",
				"wpn_cz40",
				"wpn_cz75",
				"wpn_ots33",
				"wpn_cz52",
				"wpn_tt33",
				"wpn_desert_eagle_357"
				}
	elseif (name == "Weapons (Rifle)") then
		return {
				"wpn_bm16",
				"wpn_toz34",
				"wpn_wincheaster1300",
				"wpn_spas12",
				"wpn_spas12_nimble",
				"wpn_protecta",
				"wpn_protecta_nimble",
				"wpn_ak74u",
				"wpn_mp5",
				"wpn_ak74",
				"wpn_abakan",
				"wpn_l85",
				"wpn_lr300",
				"wpn_sig550",
				"wpn_groza",
				"wpn_val",
				"wpn_vintorez",
				"wpn_svu",
				"wpn_svd",
				"wpn_rg-6",
				"wpn_rpg7",
				"wpn_g36",
				"wpn_fn2000",
				"wpn_pkm",
				"wpn_gauss",
				"wpn_wincheaster1300_trapper",
				"wpn_ak74u_snag",
				"wpn_mp5_nimble",
				"wpn_sig550_luckygun",
				"wpn_groza_nimble",
				"wpn_vintorez_nimble",
				"wpn_svu_nimble",
				"wpn_svd_nimble",
				"wpn_g36_nimble",
				"wpn_fn2000_nimble",
				"wpn_pkm_zulus",
				"pri_a17_gauss_rifle",
				"wpn_ak74u_1p29",
				"wpn_mp5sd",
				"wpn_aek971",
				"wpn_aek973",
				"wpn_ak12",
				"wpn_ak12_762",
				"wpn_ak47",
				"wpn_aks47",
				"wpn_akm",
				"wpn_akms",
				"wpn_aks74",
				"wpn_aks74n",
				"wpn_ak74m",
				"wpn_ak101",
				"wpn_ak102",
				"wpn_ak103",
				"wpn_ak104",
				"wpn_ak105",
				"wpn_p90",
				"wpn_sks",
				"wpn_g3",
				"wpn_g3a3",
				"wpn_g3sg1",
				"wpn_scar-h",
				"wpn_stg58",
				"wpn_m14",
				"wpn_m4bm",
				"wpn_m4a1",
				"wpn_mp7",
				"wpn_g36c",
				"wpn_saiga",
				"wpn_sr3m",
				"wpn_vz65",
				"wpn_mp5sd_nimble",
				"wpn_remington870",
				"wpn_mossberg",
				"wpn_9a91",
				"wpn_bizon",
				"wpn_groza1",
				"wpn_l96",
				"wpn_trg42",
				"wpn_trg22",
				"wpn_l115a3",
				"wpn_svt40",
				"wpn_mn91",
				"wpn_toz34_so",
				"wpn_izh43",
				"wpn_m134",
				"wpn_m60",
				"wpn_m249",
				"wpn_m16",
				"wpn_m16_68",
				"wpn_rpk",
				"wpn_rpk74",
				"wpn_ar15",
				"wpn_aug",
				"wpn_ump40",
				"wpn_ump45",
				"wpn_vsk94",
				"wpn_pp2000",
				"wpn_lr680",
				"wpn_avt40",
				"wpn_vepr12",
				"wpn_saiga_nimble",
				"wpn_m249_nimble",
				"wpn_vks",
				"wpn_hk416",
				"wpn_hk417",
				"wpn_m4a1_50"
			}
	elseif (name == "Weapons (Misc.)") then
		return	{
--				"explosive_barrel",
--				"explosive_mobiltank",
--				"explosive_dinamit",

				"grenade_f1",
				"grenade_rgd5",
				"grenade_gd-05",
				"wpn_knife",
				"wpn_axe",
				"wpn_binoc",
				"wpn_mine"
				}
	elseif (name == "Items (Quest)") then
		return {
				"radio_connections_pda",
		        "bad_psy_helmet",
				"good_psy_helmet",
				"jup_a9_conservation_info",
				"jup_a9_power_info",
				"jup_a9_way_info",
				"jup_a9_evacuation_info",
				"jup_a9_meeting_info",
				"jup_a9_losses_info",
				"jup_a9_delivery_info",
				"jup_b10_ufo_memory",
				"jup_b10_ufo_memory_2",
				"jup_b10_notes_01",
				"jup_b10_notes_02",
				"jup_b10_notes_03",
				"jup_b205_sokolov_note",
				"jup_b206_plant",
				"jup_b209_monster_scanner",
				"jup_b200_tech_materials_wire",
				"jup_b200_tech_materials_acetone",
				"jup_b200_tech_materials_textolite",
				"jup_b200_tech_materials_transistor",
				"jup_b200_tech_materials_capacitor",
				"jup_b202_bandit_pda",
				"device_flash_snag",
				"jup_b9_blackbox",
				"jup_b32_scanner_device",
				"jup_b46_duty_founder_pda",
				"jup_b207_merc_pda_with_contract",
				"jup_b47_jupiter_products_info",
				"jup_b47_merc_pda",
				"toolkit_1",
				"toolkit_2",
				"toolkit_3",
				"zat_b33_safe_container",
				"zat_b57_gas",
				"zat_b12_key_1",
				"zat_b12_key_2",
				"zat_b12_documents_1",
				"zat_b12_documents_2",
				"device_pda_port_bandit_leader",
				"zat_b40_notebook",
				"zat_b40_pda_1",
				"zat_b40_pda_2",
				"device_pda_zat_b5_dealer",
				"zat_b20_noah_pda",
				"zat_a23_access_card",
				"zat_a23_gauss_rifle_docs",
				"zat_b44_barge_pda",
				"zat_b39_joker_pda",
				"zat_b22_medic_pda",
				"pri_b35_lab_x8_key",
				"pri_b306_envoy_pda",
				"pri_b36_monolith_hiding_place_pda",
				"pri_a25_explosive_charge_item",
				"pri_a19_american_experiment_info",
				"pri_a19_lab_x16_info",
				"pri_a19_lab_x10_info",
				"pri_a19_lab_x7_info",
				"pri_a19_lab_x18_info",
				"zat_a23_labx8_key",
				"lx8_service_instruction"
				}
	elseif (name == "Ammo") then
		return {
				"ammo_9x18_fmj",
				"ammo_9x18_pmm",
				"ammo_9x19_fmj",
				"ammo_9x19_pbp",
				"ammo_9x19_7n21",
				"ammo_11.43x23_fmj",
				"ammo_11.43x23_hydro",
				"ammo_5.45x39_fmj",
				"ammo_5.45x39_ap",
				"ammo_5.56x45_ss190",
				"ammo_5.56x45_ap",
				"ammo_pkm_100",
				"ammo_gauss",
				"ammo_gauss_cardan",
				"ammo_9x39_pab9",
				"ammo_9x39_ap",
				"ammo_12x70_buck",
				"ammo_12x76_zhekan",
				"ammo_23x75_zhekan",
				"ammo_23x75_buck",
				"ammo_m134",
				"ammo_og-7b",
				"ammo_vog-25",
				"ammo_m209",
				"ammo_7.62x39_fmj",
				"ammo_7.62x39_ap",
				"ammo_7.62x51_fmj",
				"ammo_7.62x51_ap",
				"ammo_7.62x25_fmj",
				"ammo_7.62x25_hp",
				"ammo_357_fmj",
				"ammo_357_hp",
				"ammo_50ae_fmj",
				"ammo_50ae_hp",
				"ammo_50_beowulf_hp",
				"ammo_50_beowulf_jfp",
				"ammo_7.62x54_fmj",
				"ammo_7.62x54_7h1",
				"ammo_12.7x55",
				"ammo_8.58x70_ap",
				"ammo_8.58x70_jsp",
				"ammo_4.6x30_fmj",
				"ammo_4.6x30_ap",
				"ammo_5.7x28_ss192",
				"ammo_5.7x28_ss190",
				"ammo_6.8x43_fmj",
				"ammo_6.8x43_sst",
				"ammo_10x25_fmj",
				"ammo_10x25_hp",
				"ammo_10x22_fmj",
				"ammo_10x22_hp"
				}
	elseif (name == "NPC (Stalker)") then
		return {
				"sim_default_stalker_0",
				"sim_default_stalker_1",
				"sim_default_stalker_2",
				"sim_default_stalker_3",
				"sim_default_stalker_4",
				"sim_default_bandit_0",
				"sim_default_bandit_1",
				"sim_default_bandit_2",
				"sim_default_bandit_3",
				"sim_default_bandit_4",
				"sim_default_killer_0",
				"sim_default_killer_1",
				"sim_default_killer_2",
				"sim_default_killer_3",
				"sim_default_killer_4",
				"sim_default_duty_0",
				"sim_default_duty_1",
				"sim_default_duty_2",
				"sim_default_duty_3",
				"sim_default_duty_4",
				"sim_default_freedom_0",
				"sim_default_freedom_1",
				"sim_default_freedom_2",
				"sim_default_freedom_3",
				"sim_default_freedom_4",
				"sim_default_army_0",
				"sim_default_army_1",
				"sim_default_army_2",
				"sim_default_army_3",
				"sim_default_army_4",
				"sim_default_monolith_0",
				"sim_default_monolith_1",
				"sim_default_monolith_2",
				"sim_default_monolith_3",
				"sim_default_monolith_4",
				"sim_monolith_sniper",
				"sim_monolith_specnaz_rg6",
				"sim_default_zombied_0",
				"sim_default_zombied_1",
				"sim_default_zombied_2",
				"sim_default_zombied_3",
				"sim_default_zombied_4",
				"sim_default_csky_0",
				"sim_default_csky_1",
				"sim_default_csky_2",
				"sim_default_csky_3",
				"sim_default_csky_4",
				"sim_default_ecolog_0",
				"sim_default_ecolog_1",
				"sim_default_ecolog_2",
				"sim_default_ecolog_3",
				"sim_default_ecolog_4",
				"sim_default_military_0",
				"sim_default_military_1",
				"sim_default_military_2",
				"sim_default_military_3",
				"sim_default_military_4"
				}
	elseif (name == "NPC (Mutant)") then
		return {
				"cat_weak",
				"cat_normal",
				"cat_strong",
				"dog_weak",
				"dog_normal",
				"dog_strong",
				"rat_weak",
				"rat_normal",
				"rat_strong",
				"chimera_weak",
				"chimera_normal",
				"chimera_strong",
				"m_controller_normal",
				"m_controller_normal2",
				"bloodsucker_weak",
				"bloodsucker_normal",
				"bloodsucker_strong",
				"boar_weak",
				"boar_normal",
				"boar_strong",
				"flesh_weak",
				"flesh_normal",
				"flesh_strong",
				"fracture_weak",
				"fracture_normal",
				"fracture_strong",
				"zombie_weak",
				"zombie_normal",
				"zombie_strong",
				"gigant_weak",
				"gigant_normal",
				"gigant_strong",
				"snork_weak",
				"snork_normal",
				"snork_strong",
				"pseudodog_weak",
				"pseudodog_normal",
				"pseudodog_strong",
				"burer_weak",
				"burer_normal",
				"burer_strong",
				"tushkano_weak",
				"tushkano_normal",
				"tushkano_strong",
				"borya_normal",
				"psysucker_weak",
				"psysucker_normal",
				"psysucker_strong",
				"m_controller_psy"
				}
	elseif (name == "Squads (Stalker)") then
		return {
				"stalker_sim_squad_novice",
				"stalker_sim_squad_advanced",
				"stalker_sim_squad_veteran",
				"bandit_sim_squad_novice",
				"bandit_sim_squad_advanced",
				"bandit_sim_squad_veteran",
				"duty_sim_squad_novice",
				"duty_sim_squad_advanced",
				"duty_sim_squad_veteran",
				"freedom_sim_squad_novice",
				"freedom_sim_squad_advanced",
				"freedom_sim_squad_veteran",
				"army_sim_squad_novice",
				"army_sim_squad_advanced",
				"army_sim_squad_veteran",
				"merc_sim_squad_novice",
				"merc_sim_squad_advanced",
				"merc_sim_squad_veteran",
				"monolith_sim_squad_novice",
				"monolith_sim_squad_advanced",
				"monolith_sim_squad_veteran",
				"csky_sim_squad_novice",
				"csky_sim_squad_advanced",
				"csky_sim_squad_veteran",
				"ecolog_sim_squad_novice",
				"ecolog_sim_squad_advanced",
				"ecolog_sim_squad_veteran",
				"zombied_sim_squad_novice",
				"zombied_sim_squad_advanced",
				"zombied_sim_squad_veteran"
				}
	elseif (name == "Squads (Mutant)") then
		return {
				"simulation_bloodsucker",
				"simulation_boar",
				"simulation_burer",
				"simulation_dog",
				"simulation_pseudodog",
				"simulation_flesh",
				"simulation_snork",
				"simulation_controller",
				"simulation_mix_dogs",
				"simulation_mix_boar_flesh",
				"simulation_poltergeist_tele",
				"simulation_chimera",
				"simulation_chimera_zaton",
				"simulation_chimera_pripyat",
				"simulation_chimera_jupiter",
				"simulation_psy_dog",
				"simulation_tushkano",
				"simulation_gigant",
				"simulation_cat",
				"simulation_zombie",
				"simulation_rat",
				"simulation_rats",
				"simulation_fracture",
				"simulation_psysucker",
				"simulation_controller_psy"
				}
	elseif (name == "Vehicles") then 
		return { 
				"veh_niva",
				"veh_uaz_01",
				"veh_uaz_02",
				"veh_uaz_buhanka",
				"veh_zaz",
				"veh_zaz_968",
				"veh_moskvich",
				"veh_tr13",
				"veh_zil_130",
				"veh_zil_131",
				"veh_kamaz_fura",
				"veh_kamaz",
				"veh_laz",
				"veh_kavz",
				"veh_gaz",
				"veh_btr",
				"veh_hl2baggi"
		}
	elseif (name == "Physic (Misc.)") then
		return {
				"mine_blow",
				"jup_b209_ph_scanner",
				"jup_b207_depot_cover",
				"pri_a28_actor_hideout",
				"jup_b219_gate",
				"pri_a25_explosive_charge",
				"pri_a28_earth_helli_1",
				"pri_a28_earth_helli_2",
				"jup_b206_plant_ph",
				"shooting_target_1",
				"balon_01",
				"balon_02",
				"balon_02link",
				"balon_02a",
				"bidon",
				"bochka_close_1",
				"bochka_close_2",
				"bochka_close_3",
				"bochka_close_4",
				"gaz_balon",
				"disel_generator",
				"krisagenerator",
				"ventilator_01",
				"ventilator_02",
				"ventilator_03",
				"ventilator_04",
				"ventilator_05",
				"notebook",
				"priemnik_gorizont",
				"rupor",
				"transiver",
				"tv_1",
				"table_lamp_01",
				"komp_monitor",
				"komp_klava",
				"komp_block",
				"debris_01",
				"wood_fence_1",
				"wood_fence_2",
				"wood_fence_3",
				"wood_fence_4",
				"banka_kraski_1",
				"kanistra_01",
				"tiski",
				"kanistra_02",
				"vedro_01",
				"axe",
				"hammer",
				"hatch_01",
				"keyga",
				"lopata",
				"molot",
				"pick",
				"riffler",
				"saw",
				"box_1a",
				"box_1b",
				"box_1c",
				"box_bottle_1",
				"box_metall_01",
				"box_wood_01",
				"box_wood_02",
				"box_paper"
				}
	end
end

------------------------------------------------------------
-- List box
------------------------------------------------------------
class "set_list_text" (CUIListBoxItem)
function set_list_text:__init(height) super(height)
	self.sect					= self:GetTextItem()
	self.sect:SetWndRect		(Frect():set(0,0,300,22))
	self:SetTextColor			(GetARGB(255, 216, 186, 140))
	self.sect:SetFont			(GetFontLetterica18Russian())
	self.sect:SetWndSize		(vector2():set(400,height))
	self.sect:SetEllipsis		(true)
end

------------------------------------------------------------
-- MAIN DEBUG UI
------------------------------------------------------------
class "debug_ui" (CUIScriptWnd)
function debug_ui:__init(owner,binds) super()
	self.owner = owner
	self.binds = binds
	self.txt_console = {}
	self.tab_list = {}
	self.console_size = 27
	self:InitControls()
	self:InitCallBacks()
	self.tab:SetActiveTab("spawner")
	self:SendOutput("Alundaio's xrs_debug_tools version 2.5      [Type help for a list of commands]")
	self.console_relay = false
end

function debug_ui:__finalize()

end

function debug_ui:Reinit(level_present)
	self.level_present = level_present
	if not (level_present) then
		self.tab:SetActiveTab("editor")
	else 
		self.tab:SetActiveTab("spawner")
	end
	
	self:OnTabChange()
end 

function debug_ui:CreateTab(uID)
	self.tab_list[uID] = true
	self["dlg_"..uID] = this["debug_ui_"..uID](self,binds)
	self["dlg_"..uID]:InitControls(0,0, self.xml, self)
	self["dlg_"..uID]:Show(false)
	self.dialog:AttachChild(self["dlg_"..uID])
	self.xml:InitWindow("tab_size", 0, self["dlg_"..uID])
end

function debug_ui:InitControls()
	self:SetWndRect				(Frect():set(0,0,1024,768))
	self:Enable					(true)

	local xml					= CScriptXmlInit()
	self.xml = xml
	xml:ParseFile				("ui_debug_main.xml")

	xml:InitStatic				("background", self)
	self.dialog					= xml:InitStatic("main_dialog:dialog", self)

	-- Menu Quit
	local btn = xml:Init3tButton("main_dialog:btn_quit", self.dialog)
	self:Register(btn,"btn_quit")

	-- Teleport Button
	btn = xml:Init3tButton("main_dialog:btn_tp", self.dialog)
	self:Register(btn,"btn_tp")

	-- Console
	self.console = xml:InitStatic("console",self)
	self.console_input = xml:InitEditBox("console:input",self)
	self:Register(self.console_input,"console_input")
	
	--self.scroll_v = xml:InitScrollView("console:scroll_v", self.dialog)
	--self.scroll_v:AddWindow(self.console, true)
	
	local offset = vector2()
	offset.x = 10
	offset.y = 10

	for i=1,self.console_size do
		self.txt_console[i] = xml:InitTextWnd("console:ln",self.console)
		self.txt_console[i]:SetWndPos(offset)
		offset.y = offset.y + 15

		self.txt_console[i]:SetTextColor( GetARGB(255,240, 240, 240))
	end
	self.txt_console[1]:SetTextColor( GetARGB(255,255, 255, 255))

	-- Info
	self.form = xml:InitStatic("main_dialog:form",self.dialog)

	xml:InitStatic("main_dialog:cap_focus_id", self.dialog)
	self.txt_focus = xml:InitTextWnd("main_dialog:form:txt_focus", self.form)

	xml:InitStatic("main_dialog:cap_near_id", self.dialog)
	self.txt_near = xml:InitTextWnd("main_dialog:form:txt_near", self.form)

	-- Tabs
	--self:CreateTab("spawner")
	--self:CreateTab("editor")
	--self:CreateTab("object")
	--self:CreateTab("advanced")

	-- Dialog Tab
	self.tab = xml:InitTab("main_dialog:tab", self.dialog)
	self:Register(self.tab, "tab")
end

function debug_ui:SetCurrentValues()

end

function debug_ui:ShowConsole()
	if not (self.console:IsShown()) then
		self.console:Show(true)
		self.console_input:Show(true)
	end
end

function debug_ui:HideConsole()
	if (self.console:IsShown()) then
		self.console:Show(false)
		self.console_input:Show(false)
	end
end

function debug_ui:Update()
	CUIScriptWnd.Update(self)
end

function debug_ui:InitCallBacks()
	self:AddCallback("tab", ui_events.TAB_CHANGED, self.OnTabChange, self)
	self:AddCallback("btn_quit", ui_events.BUTTON_CLICKED, self.OnQuit, self)
	self:AddCallback("btn_tp", ui_events.BUTTON_CLICKED, self.OnBtnTeleport, self)
	self:AddCallback("btn_spawn", ui_events.BUTTON_CLICKED, self.OnBtnSpawn, self)
	self:AddCallback("btn_spawn_squad", ui_events.BUTTON_CLICKED, self.OnBtnSpawnSquad, self)
	self:AddCallback("btn_focus", ui_events.BUTTON_CLICKED, self.OnBtnFocus, self)
	self:AddCallback("btn_execute_string", ui_events.BUTTON_CLICKED, self.OnBtnExecuteString, self)
	--self:AddCallback("btn_switch_distance", ui_events.BUTTON_CLICKED, self.OnBtnSwitchDistance, self)
	self:AddCallback("btn_find", ui_events.BUTTON_CLICKED, self.OnBtnFindNearest, self)
	self:AddCallback("btn_set", ui_events.BUTTON_CLICKED, self.OnBtnSetLogic, self)
	self:AddCallback("btn_revert", ui_events.BUTTON_CLICKED, self.OnBtnRevertLogic, self)
	self:AddCallback("btn_reload", ui_events.BUTTON_CLICKED, self.OnBtnReloadIni, self)
	self:AddCallback("console_input", ui_events.EDIT_TEXT_COMMIT, self.OnConsoleInput, self)

	--- Spawner Tab
	self:AddCallback("list_sections", ui_events.LIST_ITEM_SELECT,		 self.OnSelectSectionList,		self)
	self:AddCallback("list_window",	  ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnButton_create_clicked,	self)
    --self:AddCallback("btn_create",	  ui_events.BUTTON_CLICKED,          self.OnButton_create_clicked,	self)
	
	-- Icon Editor 
	self:AddCallback("editor_list_sections", ui_events.LIST_ITEM_SELECT,		 self.OnSelectEditorSectionList,	self)
	self:AddCallback("editor_list_window",	  ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnEditorTriggerSectionSelection,	self)
	
	self:AddCallback("fld_icon_x",	  ui_events.EDIT_TEXT_COMMIT, self.OnEditIconX,	self)
	self:AddCallback("fld_icon_y",	  ui_events.EDIT_TEXT_COMMIT, self.OnEditIconY,	self)
	self:AddCallback("fld_icon_width",	  ui_events.EDIT_TEXT_COMMIT, self.OnEditIconW,	self)
	self:AddCallback("fld_icon_height",	  ui_events.EDIT_TEXT_COMMIT, self.OnEditIconH,	self)
	self:AddCallback("fld_addon_offset_x",	  ui_events.EDIT_TEXT_COMMIT, self.OnEditIconOffX,	self)
	self:AddCallback("fld_addon_offset_y",	  ui_events.EDIT_TEXT_COMMIT, self.OnEditIconOffY,	self)	
	
	self:AddCallback("editor_list_addon", ui_events.LIST_ITEM_SELECT,	self.OnEditorTriggerAddonSectionSelection,	self)
	self:AddCallback("btn_editor_save", ui_events.BUTTON_CLICKED, self.OnEditorSave, self)
	--
	
	-- level jump tab
	self:AddCallback("list_levels_window",	  ui_events.WINDOW_LBUTTON_DB_CLICK, self.JumpLevel,	self)
end

function debug_ui:OnConsoleInput()
	local txt = self.console_input:GetText()
	if (txt == "") then
		return
	end

	local wrd = ""
	local _strt, _end = string.find(txt,".%S+")
	if (_strt and _end) then
		wrd = string.sub(txt,_strt, _end)
		wrd = string.lower(wrd)
	else
		return "For usage type echo help"
	end

	if not (debug_cmd_list.command_exists(wrd)) then
		self:SendOutput("Command %s cannot be found. Type help for a list of commands.",wrd)
		return
	end

	-- Grab rest of str
	local args = string.sub(txt,string.len(wrd)+1)

	-- Trim
	args = string.gsub(args, "^%s*(.-)%s*$", "%1")

	-- Perform execute string on $vars
	local p ={}
	local var_list = debug_cmd_list.get_var_list()
	for s in string.gmatch(args,"$(.-)%$") do
		s = string.gsub(s, "^%s*(.-)%s*$", "%1")
		if (s and s ~= "" and var_list[s]) then
			table.insert(p,s)
		else
			local ls,err = loadstring("return function() local val = " .. s .."; return val; end")
			local func = ls and ls() or err
			local val = func and type(func) == "function" and func()
			table.insert(p,val)
		end
	end

	-- replace all %s with returned vals
	local i = 0
	local function sr(a)
		i = i + 1

		if ( type(p[i] ~= "userdata") )then
			if ( var_list[p[i]] and type(var_list[p[i]] ~= "userdata") ) then
				return tostring(var_list[p[i]])
			end
			return tostring(p[i])
		end
		return ""
	end
	local output = string.gsub(args,"%%s",sr)

	-- Remove all $exe_strs
	output = string.gsub(output,"$(.-)%$","")

	-- Send Output
	self:SendOutput(debug_cmd_list.command_give(wrd,output,self,p))
end

function debug_ui:OnBtnTeleport()
	local pos = xrs_debug_tools.LastCameraPos
	if (pos) then
		local car = db.actor:get_attached_vehicle()
		if (car) then 
			db.actor:detach_vehicle()
		end 
		db.actor:set_actor_position(pos)
		
		self:OnQuit()
	end
end

function debug_ui:OnBtnSpawn()
	local txt = self.fld_spawn:GetText()
	if (txt ~= "") then
		self:spawn_section(txt)
	end
end

function debug_ui:OnBtnSpawnSquad()
	local sec = self.fld_spawn_squad:GetText()
	local smrt = self.fld_spawn_smart:GetText()
	if (sec ~= "" and smrt ~= "") then
		self:spawn_squad(sec,smrt)
	end
end

function debug_ui:SendOutput(txt,...)
	if not (txt) or (txt == "") then
		return
	end

	local i = 0
	local out = txt
	local p = {...}
	if (#p > 0) then
		local function sr(a)
			i = i + 1
			return tostring(p[i])
		end
		out = string.gsub(txt,"%%s",sr)
	end

	for n=1,#self.txt_console-1,1 do
		local s = self.txt_console[n+1]:GetText()
		self.txt_console[n]:SetText(s)
	end
	self.txt_console[#self.txt_console]:SetText(out)

	if (self.console_relay) then
		printf("Debug Console: %s",out)
	end
end

function debug_ui:SendOutputList(list,start,finish)
	if not (list and not empty(list)) then
		return
	end

	local count = 1
	local n = 1
	local size = #self.txt_console
	for k,v in pairs(list) do
		if (start and count >= start) then
			if (n < (finish or size)) then
				self:SendOutput(tostring(v))
				n = n + 1
			else
				self:SendOutput(tostring(v))
				return
			end
		else
			count = count + 1
		end
	end
	for i=n,finish do 
		self:SendOutput(" ")
	end
end

function debug_ui:OnBtnFocus()
	local txt = self.fld_focus:GetText()
	if (txt ~= "") then
		xrs_debug_tools.set_debug_npc(tonumber(txt))
		self.txt_focus:SetText(txt)
	else
		xrs_debug_tools.set_debug_npc()
		self.txt_focus:SetText("")
	end
end

function debug_ui:OnBtnExecuteString()
	local txt = self.fld_execute_string:GetText()
	if (txt ~= "") then
		assert(loadstring(txt))()
	end
end

function debug_ui:OnBtnSwitchDistance()
	local txt = self.fld_switch_distance:GetText()
	if (txt ~= "") then
		local a = alife()
		local old = a:switch_distance()
		local amt = tonumber(txt)
		--alun_utils.debug_write("%s %s ",old,amt)
		a:switch_distance(amt)
		self:SendOutput("Switch Distance changed from %s to %s.",old,amt)
	end
end

function debug_ui:OnBtnFindNearest()
	local txt = self.fld_find:GetText()
	self:FindNearest(txt)
end

function debug_ui:OnBtnSetLogic()
	local section = self.fld_section:GetText()
	if (section == "") then
		return
	end
	local id = self.fld_id:GetText()
	id = id and tonumber(id)
	local scheme = utils.get_scheme_by_section(section)
	local logic = self.fld_logic:GetText()
	local ini_filename = self.fld_filename:GetText()

	if (id and scheme and section and ini_filename) then
		local obj = db.storage[id] and db.storage[id].object or level.object_by_id(id)
		if (obj) then
			axr_logic.set_new_scheme_and_logic(obj,scheme,section,logic,nil,ini_filename)
			self:SendOutput("New scheme and logic set for %s.",obj:name())
		end
	end
end

function debug_ui:OnBtnRevertLogic()
	local id = self.fld_id:GetText()
	id = id and tonumber(id)
	if (id) then
		local obj = db.storage[id] and db.storage[id].object or level.object_by_id(id)
		if (obj) then
			axr_logic.restore_scheme_and_logic(obj)
			self:SendOutput("Reverted scheme and logic for %s.",obj:name())
		end
	end
end

function debug_ui:OnBtnReloadIni()
	local txt = self.fld_reload:GetText()
	if (txt and txt ~= "") then
		local st = db.storage[tonumber(txt)]
		if (st) then
			st.ini = nil
			st.ini = xr_logic.get_customdata_or_ini_file(st.object, st.ini_filename)
			xr_logic.switch_to_section(st.object,nil,nil)
			self:SendOutput("INI reload performed on %s.",obj:name())
		end
	end
end

function debug_ui:OnQuit()
	self:HideDialog()
	if (self.level_present) then
		local console = get_console()
		console:execute("main_menu off")
	else 
		self.owner:ShowDialog()
		self.owner:Show(true)
	end
end

function debug_ui:OnTabChange()
	for k,v in pairs(self.tab_list) do 
		self["dlg_"..k]:Show(false)
	end 
	
	local ids = self.tab:GetActiveId()
	
	if (ids == "editor" or not self.level_present) then
		if not (self.dlg_editor) then
			self:CreateTab("editor")
		end
		
		self.dlg_editor:Show(true)
		
		if (self.ui_icon_equipment) then 
			self:HideConsole()
			self.ui_icon_equipment:Show(true)
			self.ui_icon_equipment_back:Show(true)
			self.icon_square:Show(true)
		end
		return
	else
		if not (self.level_present) then 
			return 
		end 
		
		if (self.ui_icon_equipment) then
			self.ui_icon_equipment:Show(false)
			self.icon_square:Show(false)
			self.ui_icon_equipment_back:Show(false)
			self:ShowConsole()
		end
	end 
	
	if not (self["dlg_"..ids]) then
		self:CreateTab(ids)
	end
	
	self["dlg_"..ids]:Show(true)
end

function debug_ui:OnKeyboard(dik, keyboard_action)
	CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if keyboard_action == ui_events.WINDOW_KEY_RELEASED then
		local keybinds = self.binds or {}
		if dik == DIK_keys.DIK_ESCAPE then
			self:OnQuit()
		elseif (keybinds["keybind_teleport_to_cam"] and dik == DIK_keys["DIK_"..keybinds["keybind_teleport_to_cam"]]) then 
			self:OnBtnTeleport()
		elseif (keybinds["debug_ui_nearest_stalker"] and dik == DIK_keys["DIK_"..keybinds["debug_ui_nearest_stalker"]]) then
			self:FindNearest("clsid.script_stalker")
		elseif (keybinds["debug_ui_spawn_position"] and dik == DIK_keys["DIK_"..keybinds["debug_ui_spawn_position"]]) then
			self.spawn_pos = db.actor:position()
			self.spawn_lvid = db.actor:level_vertex_id()
			self.spawn_gvid = db.actor:game_vertex_id()
			self:SendOutput("Set current spawning position to actor location. [To set to default type spawn reset]")
		end
	end
	return true
end

function debug_ui:spawn_section(text)
	if not system_ini():section_exist(text) then
		return false
	end

	local pos, lvid, gvid
	if (self.spawn_pos) then
		pos = self.spawn_pos
		lvid = self.spawn_lvid
		gvid = self.spawn_gvid
	else
		pos = db.actor:position()
		lvid = db.actor:level_vertex_id()
		gvid = db.actor:game_vertex_id()
	end

	local obj = alife():create(text,pos,lvid,gvid)
	--printf("Spawned Object %s as ID: %s",obj:name(),obj.id)
	self:SendOutput("Object %s created as ID %s.",obj:name(),obj.id)
	return true
end

function debug_ui:spawn_squad(section,smart)
	if not system_ini():section_exist(section) then
		self:SendOutput("UISpawner: Section %s does not exist in system INI.",section)
		return false
	end

	if not (smart) then
		self:SendOutput("UISpawner: Smart by name %s does not exist.",smart)
		return false
	end
	local sim = SIMBOARD
	if not (sim.smarts_by_names[smart]) then
		self:SendOutput("UISpawner: Smart by name %s does not exist.",smart)
		return false
	end
	local squad = alun_utils.create_squad(section,smart)
	self:SendOutput("UISpawner: Squad %s created as ID %s at %s.",squad:name(),squad.id,smart)
	return true
end

function debug_ui:FindNearest(txt)
	if (txt and txt ~= "") then
		local near,dist
		if (string.find(txt,"clsid")) then
			local cls = string.sub(txt,7)
			if (clsid[cls]) then
				near,dist = alun_utils.nearest_object(clsid[cls],true)
			end
		else
			near,dist = alun_utils.nearest_object(txt,true)
		end


		if (near) then
			local id = near.id
			local st = near:clsid() == clsid.script_stalker and db.storage[id]
			if (st) then
				local scheme = st.active_scheme
				local section = st.active_section
				local logic = st.section_logic
				local ini_filename = st.ini_filename

				if not (self.dlg_object) then 
					self:CreateTab("object")
				end 
				
				if (self.fld_id) then
					self.fld_id:SetText(id or "")
					self.fld_section:SetText(section or "")
					self.fld_logic:SetText(logic or "")
					self.fld_filename:SetText(ini_filename or "")
					if (self.fld_focus) then
						self.fld_focus:SetText(id or "")
					end
					if (self.fld_reload) then
						self.fld_reload:SetText(id or "")
					end
				end
				self.txt_near:SetText(id)
			end
			self:SendOutput("%s with ID %s found with distance %s",near:name(),id,dist)
		else
			--printf("Could not find object matching name")
			self.txt_near:SetText("Not Found")
			self:SendOutput("Object with name not found.")
		end
	end
end

function debug_ui:FillList(name)
	if not (name) then
		self:SendOutput("UISpawner: No spawn table could be created for %s",name)
		return
	end

	self.spawn_list:Clear()

	local spawntbl = get_spawn_table(name)

	if not (spawntbl) then
		self:SendOutput("UISpawner: No spawn table could be created for %s",name)
		return
	end

	
	local is_squad = string.find(name,"Squad")
	local cant_spawn_actor = string.find(name,"NPC") or string.find(name,"Physic")
	local is_veh = string.find(name,"Vehicles")
	local is_anom = string.find(name,"Anomaly")
	local is_phantom = string.find(name,"Phantom")
	if (is_squad) then 
	--	self.smarts_list:Show(true)
	else
	--	self.smarts_list:Show(false)
	end
	
	local ini = system_ini()

	table.sort(spawntbl)
	for i = 1, #spawntbl do
		if (ini:section_exist(spawntbl[i])) then
			local _itm = set_list_text(22)
			--local name = game.translate_string(system_ini():r_string_ex(sections[i], "inv_name"))

			--_itm.name:SetText(name)
			_itm.sect:SetText(spawntbl[i])

			if (is_squad) then
				_itm.no_id = true
				_itm.squad = true
			elseif (cant_spawn_actor) then
				_itm.no_id = true
			elseif (is_veh) then 
				_itm.no_id = true
				_itm.spawn_at_look = true
			elseif (is_anom) then 
				_itm.no_id = true
				_itm.spawn_at_look = true
				_itm.is_anom = true
			elseif (is_phantom) then 
				_itm.no_id = true
				_itm.spawn_at_look = true 
				_itm.use_level_spawn = true
			end

			self.spawn_list:AddExistingItem(_itm)
		end
	end
end

function debug_ui:FillEditorList(name)
	self.editor_icon:SetTextureRect(Frect():set(0,0,0,0))
	
	if not (name) then
		self:SendOutput("UIEditor: No spawn table could be created for %s",name)
		return
	end

	self.editor_spawn_list:Clear()

	local spawntbl = get_spawn_table(name)

	if not (spawntbl) then
		self:SendOutput("UIEditor: No spawn table could be created for %s",name)
		return
	end

	local ini = system_ini()

	table.sort(spawntbl)
	for i = 1, #spawntbl do
		if (ini:section_exist(spawntbl[i])) then
			local _itm = set_list_text(22)
			_itm.sect:SetText(spawntbl[i])
			self.editor_spawn_list:AddExistingItem(_itm)
		end
	end
end

function debug_ui:FillLevelList()
	local s,t = {},{}
	local levels = alun_utils.collect_section(game_ini(),"level_maps_single")
	for i,level in pairs(levels) do
		local ts = game.translate_string(level)
		table.insert(s,ts)
		t[ts] = level
	end
	
	table.sort(s) 
	
	for i,lvl_name in ipairs(s) do 
		local _itm = set_list_text(22)
		_itm.sect:SetText(lvl_name)
		_itm.name = t[lvl_name]
		self.levels_list:AddExistingItem(_itm)
	end
end 

function debug_ui:JumpLevel()
	local item
	item = self.levels_list:GetSelectedItem()
	if not(item) then
		self:SendOutput("UIAdvanced: No level was selected in the list.")
		return
	end
	
	self:OnQuit()
	
	_G.JumpToLevel(item.name)
end 

function debug_ui:OnSelectSectionList()
	self:FillList(self.sections_list:GetText())
end

function debug_ui:OnSelectEditorSectionList()
	self:FillEditorList(self.editor_sections_list:GetText())
end

function debug_ui:OnButton_create_clicked()
	if self.spawn_list:GetSize() == 0 then
		self:SendOutput("UISpawner: List is empty.")
		return
	end

	local item
	item = self.spawn_list:GetSelectedItem()
	if not(item) then
		self:SendOutput("UISpawner: No item section was selected in the list.")
		return
	end

	local section = item.sect:GetText()

	if (item.squad) then
		local smart = self.smarts_list:GetText()
		self:spawn_squad(section,smart)
		return
	end

	local pos, lvid, gvid
	
	if (item.spawn_at_look) then 
		gvid = db.actor:game_vertex_id()
		local r = level.get_target_dist and level.get_target_dist() or 3
		pos = vector():set(db.actor:position())
		pos:add(device().cam_dir:mul(r))
		pos = vector():set(pos.x,db.actor:position().y,pos.z)
		lvid = level.vertex_id(pos)
	elseif (self.spawn_pos) then
		pos = self.spawn_pos
		lvid = self.spawn_lvid
		gvid = self.spawn_gvid
	else
		pos = db.actor:position()
		lvid = db.actor:level_vertex_id()
		gvid = db.actor:game_vertex_id()
	end
	
	if (item.use_level_spawn) then 
		if (level.spawn_item) then
			level.spawn_item(section,pos,lvid,65535,false)
			self:SendOutput("UISpawner: Spawned")
		end
		return
	end

	local id = not item.no_id and self.check_to_actor:GetCheck() and 0
	local se_obj
	if (id) then
		se_obj = alife():create(section, vector(), 0, 0, id)
	else
		se_obj = alife():create(section, pos, lvid, gvid)
	end

	if not (se_obj) then
		self:SendOutput("UISpawner: Failure to create item with alife create method %s",section)
		return
	end
	
	if (item.is_anom) then 
		local data = stpk_utils.get_object_data(se_obj)
		if (data) then
			data.object_flags = 31
			--data.artefact_spawn_count = 1
			data.restrictor_type = 0
			data.shapes = {}
			data.shapes[1] = {}
			data.shapes[1].shtype = 0
			data.shapes[1].offset = vector():set(0,0,0)
			data.shapes[1].radius = 10
			stpk_utils.set_object_data(data,se_obj)
		end
	end

	self:SendOutput("UISpawner: Spawned %s on %s as id %s",se_obj:name(),id == 0 and "Actor" or "level",se_obj.id)
end

function debug_ui:OnEditorTriggerAddonSectionSelection()
	local item
	item = self.editor_spawn_list:GetSelectedItem()
	if not(item) then
		self:SendOutput("UIEditor: No item section was selected in the list.")
		return
	end

	local section = item.sect:GetText()	
	local ini = system_ini()
	if  not (ini:section_exist(section)) then
		self:SendOutput(strformat("UIEditor: Section %s does not exist",section))
		return 
	end 
	
	local addon_sec = self.addon_list:GetText()
	if not (addon_sec and addon_sec ~= "" and addon_sec ~= "Select Attachment" and ini:section_exist(addon_sec)) then
		self.editor_icon_addon:SetTextureRect(Frect():set(0,0,0,0))
		self.fld_addon_offset_x:SetText("")
		self.fld_addon_offset_y:SetText("")
		return
	end
	
	local scope_sec = section
	local ind = self.addon_list:CurrentID()
	if (self._addons[ind] == "scope" and self._scopes[ind]) then 
		local s = ini:r_string_ex(self._scopes[ind],self._addons[ind].."_name")
		addon_sec = s or addon_sec
		scope_sec = self._scopes[ind] or section
	end 
	
	local scale = 0.75
	
	local addon_inv_grid_width = ini:r_float_ex(addon_sec,"inv_grid_width") or 0
	local addon_inv_grid_height = ini:r_float_ex(addon_sec,"inv_grid_height") or 0
	local addon_inv_grid_x = ini:r_float_ex(addon_sec,"inv_grid_x") or 0
	local addon_inv_grid_y = ini:r_float_ex(addon_sec,"inv_grid_y") or 0

	local addon_x1 = addon_inv_grid_x*50
	local addon_y1 = addon_inv_grid_y*50

	local addon_w = addon_inv_grid_width*50
	local addon_h = addon_inv_grid_height*50

	local addon_x2 = addon_x1 + addon_w
	local addon_y2 = addon_y1 + addon_h
	
	local offset_x = ini:r_float_ex(scope_sec,self._addons[ind].."_x") or 0
	local offset_y = ini:r_float_ex(scope_sec,self._addons[ind].."_y") or 0
	
	self.editor_icon_addon:InitTexture("ui\\ui_icon_equipment")
	self.editor_icon_addon:SetTextureRect(Frect():set(addon_x1,addon_y1,addon_x2,addon_y2))
	self.editor_icon_addon:SetWndSize(vector2():set(addon_w*scale,addon_h*scale))
	
	pos = self.editor_icon:GetWndPos()
	self.editor_icon_addon:SetWndPos(vector2():set(pos.x+offset_x*scale,pos.y+offset_y*scale))
	
	self.fld_addon_offset_x:SetText(tostring(offset_x))
	self.fld_addon_offset_y:SetText(tostring(offset_y))
end 


function debug_ui:OnEditorTriggerSectionSelection()

	self.editor_icon:SetTextureRect(Frect():set(0,0,0,0))
	self.editor_icon_addon:SetTextureRect(Frect():set(0,0,0,0))
		
	if self.editor_spawn_list:GetSize() == 0 then
		self:SendOutput("UIEditor: List is empty.")
		return
	end
	
	local item
	item = self.editor_spawn_list:GetSelectedItem()
	if not(item) then
		self:SendOutput("UIEditor: No item section was selected in the list.")
		return
	end

	local section = item.sect:GetText()	
	local ini = system_ini()
	if  not (ini:section_exist(section)) then
		self:SendOutput(strformat("UIEditor: Section %s does not exist",section))
		return 
	end 
	
	self._addons = {} -- temp
	self._scopes = {} -- temp
	
	self.addon_list:ClearList()
	self.addon_list:AddItem("Select Attachment",0) -- default
	self._addons[0] = "none"
	
	-----------------------
	local scale = 0.75
	
	local inv_grid_width = ini:r_float_ex(section,"inv_grid_width") or 0
	local inv_grid_height = ini:r_float_ex(section,"inv_grid_height") or 0
	local inv_grid_x = ini:r_float_ex(section,"inv_grid_x") or 0
	local inv_grid_y = ini:r_float_ex(section,"inv_grid_y") or 0

	self.editor_old_x = inv_grid_x
	self.editor_old_y = inv_grid_y
	self.editor_old_w = inv_grid_width
	self.editor_old_h = inv_grid_height
	
	local x1 = inv_grid_x*50
	local y1 = inv_grid_y*50
	
	local w = inv_grid_width*50
	local h = inv_grid_height*50
	
	local x2 = x1 + w
	local y2 = y1 + h
	
	self.editor_icon:InitTexture("ui\\ui_icon_equipment")
	self.editor_icon:SetTextureRect(Frect():set(x1,y1,x2,y2))
	self.editor_icon:SetWndSize(vector2():set(w*scale,h*scale))
	local xcor = w > 250 and (-32*scale) or w < 100 and (64*scale) or w < 200 and (48*scale) or 0
	local ycor = h == 50 and (32*scale) or h == 150 and (-32*scale) or 0
	self.editor_icon:SetWndPos(vector2():set( 230 + xcor, 45 + ycor ))
	
	self.fld_icon_x:SetText(tostring(inv_grid_x))
	self.fld_icon_y:SetText(tostring(inv_grid_y))
	
	self.fld_icon_width:SetText(tostring(inv_grid_width))
	self.fld_icon_height:SetText(tostring(inv_grid_height))
	
	local pos = self.ui_icon_equipment:GetWndPos()
	self.icon_square:SetWndPos(vector2():set( pos.x+x1/4 , pos.y+y1/4 ))
	self.icon_square:SetWndSize(vector2():set(w/4,h/4))
	
	-- attachments
	local silencer = ini:r_string_ex(section,"silencer_name")
	local grenade_launcher = ini:r_string_ex(section,"grenade_launcher_name")
	
	local ind = 1
	if (silencer and ini:section_exist(silencer)) then
		self.addon_list:AddItem(silencer,ind)
		self._addons[ind] = "silencer"
		ind = ind + 1
	end 
	
	if (grenade_launcher and ini:section_exist(grenade_launcher)) then 
		self.addon_list:AddItem(grenade_launcher,ind)
		self._addons[ind] = "grenade_launcher"
		ind = ind + 1
	end 
	
	local scopes = alun_utils.parse_list(ini,section,"scopes_sect")
	if (scopes and #scopes > 0) then
		for k,v in pairs(scopes) do
			self.addon_list:AddItem(v,ind)
			self._scopes[ind] = v
			self._addons[ind] = "scope"
			ind = ind + 1
		end
	end 
	
	self.editor_icon_addon:SetTextureRect(Frect():set(0,0,0,0))
	self.fld_addon_offset_x:SetText("")
	self.fld_addon_offset_y:SetText("")
--[[
	local name = self.addon_list:GetText()
	if not (name and name ~= "Select Addon Type") then
		return 
	end 
	
	local scopes = name == "scope" and alun_utils.parse_list(ini,section,"scopes_sect")
	local scope_sec = section
	if (scopes and #scopes > 0) then 
		scope_sec = scopes[1]
	end 
	
	local addon_sec = alun_utils.read_from_ini(ini,scope_sec,name.."_name","string")
	if not (addon_sec and ini:section_exist(addon_sec)) then
		return 
	end
	
	local addon_inv_grid_width = alun_utils.read_from_ini(ini,addon_sec,"inv_grid_width","float",0)
	local addon_inv_grid_height = alun_utils.read_from_ini(ini,addon_sec,"inv_grid_height","float",0)
	local addon_inv_grid_x = alun_utils.read_from_ini(ini,addon_sec,"inv_grid_x","float",0)
	local addon_inv_grid_y = alun_utils.read_from_ini(ini,addon_sec,"inv_grid_y","float",0)

	local addon_x1 = addon_inv_grid_x*50
	local addon_y1 = addon_inv_grid_y*50

	local addon_w = addon_inv_grid_width*50
	local addon_h = addon_inv_grid_height*50

	local addon_x2 = addon_x1 + addon_w
	local addon_y2 = addon_y1 + addon_h
	
	local offset_x = alun_utils.read_from_ini(ini,scope_sec,name.."_x","float",0)
	local offset_y = alun_utils.read_from_ini(ini,scope_sec,name.."_y","float",0)
	
	self.editor_old_offset_x = offset_x
	self.editor_old_offset_y = offset_y
	
	self.editor_icon_addon:InitTexture("ui\\ui_icon_equipment")
	self.editor_icon_addon:SetTextureRect(Frect():set(addon_x1,addon_y1,addon_x2,addon_y2))
	self.editor_icon_addon:SetWndSize(vector2():set(addon_w*scale,addon_h*scale))
	
	pos = self.editor_icon:GetWndPos()
	self.editor_icon_addon:SetWndPos(vector2():set(pos.x+offset_x*scale,pos.y+offset_y*scale))
	
	self.fld_addon_offset_x:SetText(tostring(offset_x))
	self.fld_addon_offset_y:SetText(tostring(offset_y))
--]]
end 

function debug_ui:OnEditIconX()
	local v = tonumber(self.fld_icon_x:GetText())
	if (v and v ~= self.editor_old_x) then 
		self.need_save_x = true
	end
	
	self:OnEditIcon()
end 

function debug_ui:OnEditIconY()
	local v = tonumber(self.fld_icon_y:GetText())
	if (v and v ~= self.editor_old_y) then 
		self.need_save_y = true
	end
	
	self:OnEditIcon()
end 

function debug_ui:OnEditIconW()
	local v = tonumber(self.fld_icon_width:GetText())
	if (v and v ~= self.editor_old_w) then 
		self.need_save_w = true
	end
	
	self:OnEditIcon()
end 

function debug_ui:OnEditIconH()
	local v = tonumber(self.fld_icon_height:GetText())
	if (v and v ~= self.editor_old_h) then 
		self.need_save_h = true
	end
	
	self:OnEditIcon()
end 

function debug_ui:OnEditIconOffX()
	local v = tonumber(self.fld_addon_offset_x:GetText())
	if (v and v ~= self.editor_old_offset_x) then 
		self.need_save_offset_x = true
	end 
	self:OnEditIcon()
end 

function debug_ui:OnEditIconOffY()
	local v = tonumber(self.fld_addon_offset_y:GetText())
	if (v and v ~= self.editor_old_offset_y) then 
		self.need_save_offset_y = true
	end 
	self:OnEditIcon()
end 

function debug_ui:OnEditIcon()

	local x1 = tonumber(self.fld_icon_x:GetText())
	local y1 = x1 and tonumber(self.fld_icon_y:GetText())
	
	local w = y1 and tonumber(self.fld_icon_width:GetText())
	local h = w and tonumber(self.fld_icon_height:GetText())
	
	if not (x1 and y1 and w and h) then 
		return
	end 
	
	local scale = 0.75
	
	x1 = x1*50
	y1 = y1*50 
	w = w*50 
	h = h*50
	
	local x2 = x1 + w
	local y2 = y1 + h
	
	--self.editor_icon:InitTexture("ui\\ui_icon_equipment")
	self.editor_icon:SetTextureRect(Frect():set(x1,y1,x2,y2))
	self.editor_icon:SetWndSize(vector2():set(w*scale,h*scale))
	
	local pos = self.ui_icon_equipment:GetWndPos()
	self.icon_square:SetWndPos(vector2():set( pos.x+x1/4 , pos.y+y1/4 ))
	self.icon_square:SetWndSize(vector2():set(w/4,h/4))
	
	local name = self.addon_list:GetText()
	if not (name and name ~= "" and name ~= "Select Attachment") then
		self.editor_icon_addon:SetTextureRect(Frect():set(0,0,0,0))
		self.fld_addon_offset_x:SetText("")
		self.fld_addon_offset_y:SetText("")
		return
	end
	
	local offset_x = tonumber(self.fld_addon_offset_x:GetText())
	local offset_y  = offset_x and tonumber(self.fld_addon_offset_y:GetText())
	
	if not (offset_y) then
		self.editor_icon_addon:SetTextureRect(Frect():set(0,0,0,0))
		self.fld_addon_offset_x:SetText("")
		self.fld_addon_offset_y:SetText("")
		return 
	end 
	
	pos = self.editor_icon:GetWndPos()
	self.editor_icon_addon:SetWndPos(vector2():set(pos.x+offset_x*scale,pos.y+offset_y*scale))
end 

function debug_ui:OnEditorSave()
	if not (self.need_save_x or self.need_save_y or self.need_save_w or self.need_save_h or self.need_save_offset_x or self.need_save_offset_y) then 
		return 
	end 
	
	local x1 = tonumber(self.fld_icon_x:GetText())
	local y1 = x1 and tonumber(self.fld_icon_y:GetText())
	
	local w = y1 and tonumber(self.fld_icon_width:GetText())
	local h = w and tonumber(self.fld_icon_height:GetText())

	if not (h) then 
		return
	end 

	local offset_x = tonumber(self.fld_addon_offset_x:GetText())
	local offset_y  = offset_x and tonumber(self.fld_addon_offset_y:GetText())
	
	local item = self.editor_spawn_list:GetSelectedItem()
	if not(item) then
		self:SendOutput("UIEditorSave: No item section was selected in the list.")
		return
	end

	local section = item.sect:GetText()	
	local ini = system_ini()
	if  not (ini:section_exist(section)) then
		self:SendOutput(strformat("UIEditorSave: Section %s does not exist",section))
		return 
	end
	
	local ind = self.addon_list:CurrentID()
	local addon_sec = self.addon_list:GetTextOf(ind)
	if (addon_sec == nil or addon_sec == "" or addon_sec == "Select Attachment") then
		addon_sec = nil
		self.need_save_offset_x = nil
		self.need_save_offset_y = nil
		ind = 0
	end
	
	local search_sec = self._addons[ind] == "scope" and self._scopes[ind] or section
	
	local function file_exists(path)
		return io.open(path) ~= nil
	end
	
	local function on_execute(path,filename,quit)
		local fullpath = path.."\\"..filename
		local ltx = io.open(fullpath,"rb")
		if (ltx) then
			local data = ltx:read("*all")
			ltx:close()
			if (data) then
				if (string.find(data,"["..section.."]",nil,true)) then
					ltx = alun_utils.cfg_file(fullpath)
					if (ltx) then
						if (self.need_save_x) then
							ltx:SetValue(section,"inv_grid_x",x1)
						end 
						if (self.need_save_y) then
							ltx:SetValue(section,"inv_grid_y",y1)
						end
						if (self.need_save_w) then
							ltx:SetValue(section,"inv_grid_width",w)
						end
						if (self.need_save_h) then
							ltx:SetValue(section,"inv_grid_height",h)
						end
						ltx:SaveExt()
					else 
						printf("make sure your gamedata is unpacked from db!")
					end
				end
				if (self.need_save_offset_x or self.need_save_offset_y) and (string.find(data,"["..search_sec.."]",nil,true)) then
					ltx = alun_utils.cfg_file(fullpath)
					if (ltx) then
						if (self.need_save_offset_x) then
							ltx:SetValue(search_sec,self._addons[ind].."_x",offset_x)
						end 
						if (self.need_save_offset_y) then
							ltx:SetValue(search_sec,self._addons[ind].."_y",offset_y)
						end
						ltx:SaveExt()
					else 
						printf("make sure your gamedata is unpacked from db!")
					end
				end
			end
		end
	end

	local sp = getFS():update_path('$game_config$', '')
	sp = string.sub(sp,0,string.len(sp)-1)
	lua_extensions.recurse_subdirectories_and_execute(sp,{"ltx"},on_execute)
	
	if (reload_system_ini) then 
		reload_system_ini()
	end
	
	self.need_save_x = nil
	self.need_save_y = nil	
	self.need_save_w = nil
	self.need_save_h = nil
	self.need_save_offset_x = nil
	self.need_save_offset_y = nil
end


-- SPAWNER UI
class "debug_ui_spawner" (CUIWindow)
function debug_ui_spawner:__init(owner, binds) super()
	self.owner = owner
end
function debug_ui_spawner:__finalize()

end

function debug_ui_spawner:InitControls(x, y, xml, owner)
	self:SetWndPos(vector2():set(x-50,y))
	self:SetWndSize(vector2():set(800,416))
	self:SetAutoDelete(true)

	owner.sections_list = xml:InitComboBox("tab_spawner:list_sections", self)
	owner.sections_list:ClearList()
	owner.sections_list:SetAutoDelete(true)

	for i=1,#id_to_spawn_table do
		owner.sections_list:AddItem(id_to_spawn_table[i],i-1)
	end

	owner:Register(owner.sections_list, "list_sections")

	owner.spawn_list_frame = xml:InitFrame("tab_spawner:list_frame",self)
	owner.spawn_list = xml:InitListBox("tab_spawner:list",self)
	owner.spawn_list:ShowSelectedItem(true)

	owner:Register(owner.spawn_list, "list_window")

	owner.check_to_actor = xml:InitCheck("tab_spawner:check_own_to_actor",self)
	owner.check_to_actor:SetCheck(true)

	--local ctrl = xml:Init3tButton("tab_spawner:btn_create",self)
	--owner:Register(ctrl, "btn_create")


	owner.smarts_list = xml:InitComboBox("tab_spawner:list_smarts", self)
	owner.smarts_list:ClearList()
	owner.smarts_list:SetAutoDelete(true)
	
	local sim = alife()
	local actor_level = sim:level_name(game_graph():vertex(sim:actor().m_game_vertex_id):level_id())
	local board = SIMBOARD
	local smrts = {}
	for id,t in pairs(board.smarts) do
		if (t.smrt and actor_level == t.smrt.smart_level) then
			smrts[#smrts+1] = t.smrt:name()
		end
	end
	
	table.sort(smrts)
	for i=1,#smrts do
		owner.smarts_list:AddItem(smrts[i],i)	
	end

	owner.smarts_list:SetText("Squad to Smart")
	
	--owner.smarts_list:Show(false)
	
	owner.smarts_list_cap = xml:InitStatic("tab_spawner:cap_smarts", self)

	--owner:Register(owner.smarts_list, "list_smarts")

	-- Set defaults
	owner.sections_list:SetText(owner.sections_list:GetTextOf(0))
	owner:FillList(owner.sections_list:GetTextOf(0))

	------------------------- manual input 
	xml:InitStatic("tab_spawner:cap_spawn", self)
	owner.fld_spawn = xml:InitEditBox("tab_spawner:fld_spawn", self)

	btn = xml:Init3tButton("tab_spawner:btn_spawn",self)
	owner:Register(btn, "btn_spawn")

	xml:InitStatic("tab_spawner:cap_spawn_squad", self)
	owner.fld_spawn_squad = xml:InitEditBox("tab_spawner:fld_spawn_squad", self)

	xml:InitStatic("tab_spawner:cap_spawn_smart", self)
	owner.fld_spawn_smart = xml:InitEditBox("tab_spawner:fld_spawn_smart", self)

	btn = xml:Init3tButton("tab_spawner:btn_spawn_squad",self)
	owner:Register(btn, "btn_spawn_squad")
end

-- HUD UI
class "debug_ui_hud" (CUIWindow)
function debug_ui_hud:__init(owner, binds) super()
	self.owner = owner
end
function debug_ui_hud:__finalize()

end
function debug_ui_hud:InitControls(x, y, xml, owner)
	self:SetWndPos(vector2():set(x,y))
	self:SetWndSize(vector2():set(800,416))
	self:SetAutoDelete(true)

	xml:InitStatic("tab_hud:cap_focus", self)
	owner.fld_focus = xml:InitEditBox("tab_hud:fld_focus", self)

	local btn = xml:Init3tButton("tab_hud:btn_focus",self)
	owner:Register(btn, "btn_focus")
end

-- object UI
class "debug_ui_object" (CUIWindow)
function debug_ui_object:__init(owner, binds) super()
	self.owner = owner
end
function debug_ui_object:__finalize()

end
function debug_ui_object:InitControls(x, y, xml, owner)
	self:SetWndPos(vector2():set(x,y))
	self:SetWndSize(vector2():set(800,416))
	self:SetAutoDelete(true)

	xml:InitStatic("tab_object:cap_find", self)
	owner.fld_find = xml:InitEditBox("tab_object:fld_find", self)

	local btn
	btn = xml:Init3tButton("tab_object:btn_find",self)
	owner:Register(btn, "btn_find")

	xml:InitStatic("tab_object:cap_id", self)
	owner.fld_id = xml:InitEditBox("tab_object:fld_id", self)

	xml:InitStatic("tab_object:cap_section", self)
	owner.fld_section = xml:InitEditBox("tab_object:fld_section", self)

	xml:InitStatic("tab_object:cap_logic", self)
	owner.fld_logic = xml:InitEditBox("tab_object:fld_logic", self)

	xml:InitStatic("tab_object:cap_filename", self)
	owner.fld_filename = xml:InitEditBox("tab_object:fld_filename", self)

	btn = xml:Init3tButton("tab_object:btn_set",self)
	owner:Register(btn, "btn_set")

	btn = xml:Init3tButton("tab_object:btn_revert",self)
	owner:Register(btn, "btn_revert")

	xml:InitStatic("tab_object:cap_reload", self)
	owner.fld_reload = xml:InitEditBox("tab_object:fld_reload", self)

	btn = xml:Init3tButton("tab_object:btn_reload",self)
	owner:Register(btn, "btn_reload")
end

-- ADVANCED UI
class "debug_ui_advanced" (CUIWindow)
function debug_ui_advanced:__init(owner, binds) super()
	self.owner = owner
end
function debug_ui_advanced:__finalize()

end
function debug_ui_advanced:InitControls(x, y, xml, owner)
	self:SetWndPos(vector2():set(x,y))
	self:SetWndSize(vector2():set(800,416))
	self:SetAutoDelete(true)

	xml:InitStatic("tab_advanced:cap_execute_string", self)
	owner.fld_execute_string = xml:InitEditBox("tab_advanced:fld_execute_string", self)

	local btn = xml:Init3tButton("tab_advanced:btn_execute_string",self)
	owner:Register(btn, "btn_execute_string")

	xml:InitStatic("tab_advanced:cap_jump_level", self)
	
	owner.levels_list_frame = xml:InitFrame("tab_advanced:list_frame",self)
	owner.levels_list = xml:InitListBox("tab_advanced:list",self)
	owner.levels_list:ShowSelectedItem(true)

	owner:Register(owner.levels_list, "list_levels_window")
	
	owner:FillLevelList()
end

-- ICON EDITOR
class "debug_ui_editor" (CUIWindow)
function debug_ui_editor:__init(owner, binds) super()
	self.owner = owner
end
function debug_ui_editor:__finalize()

end
function debug_ui_editor:InitControls(x, y, xml, owner)
	self:SetWndPos(vector2():set(x-50,y))
	self:SetWndSize(vector2():set(800,416))
	self:SetAutoDelete(true)

	owner.editor_sections_list = xml:InitComboBox("tab_editor:list_sections", self)
	owner.editor_sections_list:ClearList()
	owner.editor_sections_list:SetAutoDelete(true)

	local invalid_ids = {[6] = true , [7] = true, [9] = true, [10] = true, [11] = true}
	for i=1,#id_to_spawn_table do
		if not (invalid_ids[i]) then
			owner.editor_sections_list:AddItem(id_to_spawn_table[i],i-1)
		end
	end

	owner:Register(owner.editor_sections_list, "editor_list_sections")

	owner.editor_spawn_list_frame = xml:InitFrame("tab_editor:list_frame",self)
	owner.editor_spawn_list = xml:InitListBox("tab_editor:list",self)
	owner.editor_spawn_list:ShowSelectedItem(true)

	owner:Register(owner.editor_spawn_list, "editor_list_window")

	owner.editor_icon_back = xml:InitStatic("tab_editor:icon_back",self)
	owner.editor_icon = xml:InitStatic("tab_editor:icon",self)
	
	-- Set defaults
	owner.editor_sections_list:SetText(owner.editor_sections_list:GetTextOf(0))
	owner:FillEditorList(owner.editor_sections_list:GetTextOf(0))
	

	-------
	xml:InitStatic("tab_editor:cap_w", self)
	owner.fld_icon_width = xml:InitEditBox("tab_editor:fld_w", self)
	owner:Register(owner.fld_icon_width,"fld_icon_width")
	
	xml:InitStatic("tab_editor:cap_h", self)
	owner.fld_icon_height = xml:InitEditBox("tab_editor:fld_h", self)
	owner:Register(owner.fld_icon_height,"fld_icon_height")
	
	xml:InitStatic("tab_editor:cap_x", self)
	owner.fld_icon_x = xml:InitEditBox("tab_editor:fld_x", self)
	owner:Register(owner.fld_icon_x,"fld_icon_x")
	
	xml:InitStatic("tab_editor:cap_y", self)
	owner.fld_icon_y = xml:InitEditBox("tab_editor:fld_y", self)
	owner:Register(owner.fld_icon_y,"fld_icon_y")
	
	
	owner.ui_icon_equipment_back = xml:InitFrame("ui_icon_equipment_back",owner)
	owner.ui_icon_equipment = xml:InitStatic("ui_icon_equipment",owner)
	
	owner.ui_icon_equipment:InitTexture("ui\\ui_icon_equipment")
	owner.ui_icon_equipment:SetWndSize(vector2():set(UI_ICON_EQUIPMENT_WIDTH/4,UI_ICON_EQUIPMENT_HEIGHT/4))
	owner.ui_icon_equipment_back:SetWndSize(vector2():set(UI_ICON_EQUIPMENT_WIDTH/4+20,UI_ICON_EQUIPMENT_HEIGHT/4+20))
	
	
	owner.icon_square = xml:InitFrame("square",owner)
	
	xml:InitStatic("tab_editor:cap_addon_x", self)
	owner.fld_addon_offset_x = xml:InitEditBox("tab_editor:fld_addon_x", self)
	owner:Register(owner.fld_addon_offset_x,"fld_addon_offset_x")
	
	xml:InitStatic("tab_editor:cap_addon_y", self)
	owner.fld_addon_offset_y = xml:InitEditBox("tab_editor:fld_addon_y", self)
	owner:Register(owner.fld_addon_offset_y,"fld_addon_offset_y")
	
	owner.addon_list = xml:InitComboBox("tab_editor:list_addon", self)
	owner:Register(owner.addon_list, "editor_list_addon")
	local t = {"Select Addon Type", "silencer", "grenade_launcher", "scope" }
	for i=1,#t do
		owner.addon_list:AddItem(t[i],i-1)
	end
	
	owner.addon_list:SetText("Select Addon Type")
	
	owner.editor_icon_addon = xml:InitStatic("tab_editor:icon_addon",self)
	
	local btn = xml:Init3tButton("tab_editor:btn_save",self)
	owner:Register(btn, "btn_editor_save")
end

---------------------------------------------------- Attach Offsets
local _attached
local _last_section

class "debug_ui_attach" (CUIScriptWnd)
function debug_ui_attach:__init(owner, binds) super()
	self:SetWndRect				(Frect():set(0,0,1024,768))
	self:Enable					(true)

	local xml					= CScriptXmlInit()
	self.xml = xml
	xml:ParseFile				("ui_debug_main.xml")
	
	self:SetAutoDelete(true)
	self.owner = owner
	self.need_save = {}

	local ctrl = CUIWindow()
	self.xml:InitWindow("wnd_attach_editor:file_item:main",0,ctrl)
	self.form = self.xml:InitStatic("wnd_attach_editor:form",self)
	self.xml:InitFrame("wnd_attach_editor:form:list_frame",self.form)

	ctrl = self.xml:Init3tButton("wnd_attach_editor:form:btn_attach",self.form)
	self:Register(ctrl, "button_attach_npc")
	self:AddCallback("button_attach_npc", ui_events.BUTTON_CLICKED, self.OnAttach, self)
	
	--[[
	ctrl = self.xml:Init3tButton("wnd_attach_editor:form:btn_save",self.form)
	self:Register(ctrl, "button_attach_save")
	self:AddCallback("button_attach_save", ui_events.BUTTON_CLICKED, self.OnAttachSave, self)
	--]]
	
	xml:InitStatic("wnd_attach_editor:form:cap_pos", self.form)
	xml:InitStatic("wnd_attach_editor:form:cap_angle", self.form)
	
	self.flds = {"x","y","z","rot_x","rot_y","rot_z"}
	for i=1,#self.flds do
		xml:InitStatic("wnd_attach_editor:form:cap_"..self.flds[i], self.form)
		self["fld_attach_"..self.flds[i]] = xml:InitEditBox("wnd_attach_editor:form:fld_"..self.flds[i], self.form)
		self:Register(self["fld_attach_"..self.flds[i]],"fld_attach_"..self.flds[i])
		
		self:AddCallback("fld_attach_"..self.flds[i],	  ui_events.EDIT_TEXT_COMMIT, self["On_fld_attach_"..self.flds[i]],	self)
	end 

	self.attachable = xml:InitComboBox("wnd_attach_editor:form:list_attach", self.form)
	self:Register(self.attachable, "attach_list")
	self:AddCallback("attach_list", ui_events.LIST_ITEM_SELECT,	self.OnAttachListSelect,self)
	
	local sys_ini = system_ini()
	local t = alun_utils.parse_list(sys_ini,"stalker","attachable_items")
	if (#t > 0) then
		for i=1,#t do
			if (sys_ini:section_exist(t[i])) then
				self.attachable:AddItem(t[i],i-1)
			end
		end
	end
	
	-- TODO:
	-- NOT IMPLEMENTED FULLY YET
	--[[
	self.weapons = xml:InitComboBox("wnd_attach_editor:form:list_weapons", self.form)
	self:Register(self.weapons, "weapon_list")
	self:AddCallback("weapon_list", ui_events.LIST_ITEM_SELECT,	self.OnWeaponListSelect,self)
	
	local valid_ids = {13,14,15} -- Weapon spawn tables only
	
	for n=1,#valid_ids do 
		local slist = get_spawn_table(id_to_spawn_table[ valid_ids[n] ])
		if (slist) then 
			local cnt = 0
			for i=1,#slist do
				if (sys_ini:section_exist(slist[i])) then
					self.weapons:AddItem(slist[i],cnt)
					cnt = cnt + 1
				end
			end
		end
	end
	--]]
	
	self.anim_states = xml:InitComboBox("wnd_attach_editor:form:list_states", self.form)
	self:Register(self.anim_states, "state_list")
	self:AddCallback("state_list", ui_events.LIST_ITEM_SELECT,	self.OnStateListSelect,self)
	
	t = clear_table(t) or {}
	
	for state,_ in pairs(state_lib.states) do 
		table.insert(t,state)
	end
	
	table.sort(t)
	
	for i=1,#t do 
		self.anim_states:AddItem(t[i],#t-1)
	end
end
function debug_ui_attach:__finalize()

end
function debug_ui_attach:OnAttachListSelect()
	self._last = "attach"
	for i=1,#self.flds do
		self.need_save[self.flds[i]] = nil
	end 
	
	local section = self.attachable:GetText()
	if not (section and system_ini():section_exist(section)) then 
		return 
	end 
	
	local pos = alun_utils.parse_list(system_ini(),section,"attach_position_offset")
	local angle = alun_utils.parse_list(system_ini(),section,"attach_angle_offset")
	
	if not (#pos > 0) then
		return 
	end
	
	for i=1,#pos do 
		if (self["fld_attach_"..self.flds[i]]) then 
			self["fld_attach_"..self.flds[i]]:SetText(pos[i])
		end
	end
	
	if not (#angle > 0) then
		return
	end
	
	for i=1,#angle do 
		if (self["fld_attach_"..self.flds[i+3]]) then 
			self["fld_attach_"..self.flds[i+3]]:SetText(angle[i])
		end
	end
end

function debug_ui_attach:OnStateListSelect()
	local state = self.anim_states:GetText()
	if not (state and state ~= "") then 
		return 
	end
	
	local npc = xrs_debug_tools.get_debug_npc() or xrs_debug_tools.NEAREST_STALKER
	if not (npc and npc:id() ~= 0) then
		return 
	end
	
	db.storage[npc:id()].debug_state = state
	state_mgr.set_state(npc, state,nil, nil, nil, { fast_set = true })
end 

function debug_ui_attach:OnWeaponListSelect()
	self._last = "weapon"
	for i=1,#self.flds do
		self.need_save[self.flds[i]] = nil
	end 
	
	local section = self.weapons:GetText()
	if not (section and system_ini():section_exist(section)) then 
		return 
	end 
	
	local pos = alun_utils.parse_list(system_ini(),section,"position")
	local angle = alun_utils.parse_list(system_ini(),section,"orientation")
	
	if not (#pos > 0) then
		return 
	end
	
	for i=1,#pos do 
		if (self["fld_attach_"..self.flds[i]]) then 
			self["fld_attach_"..self.flds[i]]:SetText(pos[i])
		end
	end
	
	if not (#angle > 0) then
		return
	end
	
	for i=1,#angle do 
		if (self["fld_attach_"..self.flds[i+3]]) then 
			self["fld_attach_"..self.flds[i+3]]:SetText(angle[i])
		end
	end
end
function debug_ui_attach:OnAttachSave(section)
	local need_save
	local fld
	local vals = {}
	for i=1,#self.flds do
		fld = self["fld_attach_"..self.flds[i]]
		if not (fld) then 
			return 
		end
		
		if not (tonumber(fld:GetText())) then 
			return 
		end
		
		if (self.need_save[self.flds[i]] == true) then
			need_save = true
		end
		
		vals[self.flds[i]] = tonumber(fld:GetText())
	end 
	
	if not (need_save) then 
		return 
	end

	local function file_exists(path)
		return io.open(path) ~= nil
	end
	
	local function on_execute(path,filename,quit)
		local fullpath = path.."\\"..filename
		local ltx = io.open(fullpath,"rb")
		if (ltx) then
			local data = ltx:read("*all")
			ltx:close()
			if (data) then
				if (string.find(data,"["..section.."]",nil,true)) then
					ltx = alun_utils.cfg_file(fullpath)
					if (ltx) then
						if (self._last == "attach") then
							if (self.need_save.x or self.need_save.y or self.need_save.z) then
								ltx:SetValue(section,"attach_position_offset",vals.x .. ", " .. vals.y .. ", " .. vals.z)
							end
							
							if (self.need_save.rot_x or self.need_save.rot_y or self.need_save.rot_z) then
								ltx:SetValue(section,"attach_angle_offset",vals.rot_x .. ", " .. vals.rot_y .. ", " .. vals.rot_z)
							end
						elseif (self._last == "weapon") then
							if (self.need_save.x or self.need_save.y or self.need_save.z) then
								ltx:SetValue(section,"position",vals.x .. ", " .. vals.y .. ", " .. vals.z)
							end
							
							if (self.need_save.rot_x or self.need_save.rot_y or self.need_save.rot_z) then
								ltx:SetValue(section,"orientation",vals.rot_x .. ", " .. vals.rot_y .. ", " .. vals.rot_z)
							end
						end
						
						ltx:SaveExt()
						return
					end
				end
			end
		end
	end

	local sp = getFS():update_path('$game_config$', '')
	sp = string.sub(sp,0,string.len(sp)-1)
	lua_extensions.recurse_subdirectories_and_execute(sp,{"ltx"},on_execute)
	
	if (reload_system_ini) then 
		reload_system_ini()
	end
end
function debug_ui_attach:On_fld_attach_x()
	self:OnEditAttach("x")
end 
function debug_ui_attach:On_fld_attach_y()
	self:OnEditAttach("y")
end 
function debug_ui_attach:On_fld_attach_z()
	self:OnEditAttach("z")
end 
function debug_ui_attach:On_fld_attach_rot_x()
	self:OnEditAttach("rot_x")
end 
function debug_ui_attach:On_fld_attach_rot_y()
	self:OnEditAttach("rot_y")
end 
function debug_ui_attach:On_fld_attach_rot_z()
	self:OnEditAttach("rot_z")
end 
function debug_ui_attach:OnEditAttach(fld)
	if not (_attached) then 
		return 
	end 
	local section = self._last == "attach" and self.attachable:GetText() or self._last == "weapon" and self.weapons:GetText() or nil
	if not (section and system_ini():section_exist(section)) then 
		return 
	end
	
	local itm = level.object_by_id(_attached)
	if not (itm) then 
		return 
	end 
	
	if not (section == itm:section()) then
		printf("ERROR: ui_debug_main.debug_ui_attach : section in combo box is not same section as item! itm=%s selected=%s",itm:section(),section)
		return 
	end 
	
	self.need_save[fld] = true

	self:OnAttachSave(section)
	
	itm:attachable_item_load_attach(section)
end 
function debug_ui_attach:OnKeyboard(dik, keyboard_action)
	CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if keyboard_action == ui_events.WINDOW_KEY_RELEASED then
		local keybinds = self.binds or {}
		if (dik == DIK_keys.DIK_ESCAPE) then
			self:OnQuit()
		end
	end
	return true
end
local function delayed_attach(id)
	local itm = id and level.object_by_id(id)
	if (itm) then
		itm:enable_attachable_item(true)
		_attached = itm:id()
		return true
	end
	return false
end
function debug_ui_attach:OnAttach()
	local npc = xrs_debug_tools.get_debug_npc() or xrs_debug_tools.NEAREST_STALKER
	if not (npc and npc:id() ~= 0) then
		return 
	end
	
	local section = self._last == "attach" and self.attachable:GetText() or self._last == "weapon" and self.weapons:GetText() or nil
	if not (section and system_ini():section_exist(section)) then 
		return 
	end
	
	if (_last_section ~= section) then 
		_last_section = section
		if (_attached) then 
			local itm = level.object_by_id(_attached)
			if (itm) then
				itm:enable_attachable_item(false)
			end
			_attached = nil
		end
	end
		
	local itm = npc:object(section)
	if not (itm) then 
		local se_itm = alife():create(section,npc:position(),npc:level_vertex_id(),npc:game_vertex_id(),npc:id())
		if (se_itm) then
			CreateTimeEvent(se_itm.id,"delayed_attach",1,delayed_attach,se_itm.id)
		end
	else
		if (_attached) then 
			itm:enable_attachable_item(false)
		end
		_attached = itm:id()
		CreateTimeEvent(itm:id(),"delayed_attach",1,delayed_attach,itm:id())
	end
end 
function debug_ui_attach:OnQuit()
	self:HideDialog()
end