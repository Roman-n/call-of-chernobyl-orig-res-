function normalize(val, min, max)
	local d = 100*(val-min)/(max-min)
	if d < 0 then
		return 0
	end
	return utils.clamp(d,0,100)
end

function normalizeMP(val)
	if val > 100 then
		val = 100
	elseif val < 1 then
		val  = 1
	end
	
	return val
end

function read_if_exist(section, value, default)
    local ltx = system_ini()
    if ltx:section_exist(section) and ltx:line_exist(section,value) then
		return ltx:r_float_ex(section,value)
	else
		return default
	end
end

function read_float(wpn_section, upgr_sections, param)
	local ltx = system_ini()
	local res = 0
	
	local class = ltx:r_string_ex(wpn_section,"class")
	if (class == "WP_RG6") then 
		local ammo_section = parse_names(ltx:r_string_ex(wpn_section,"ammo_class") or "")[1] or ""
		local fake_grenade_name = ltx:r_string_ex(ammo_section,"fake_grenade_name")
		return fake_grenade_name and ltx:r_float_ex(fake_grenade_name,"blast") or 0
	elseif (class == "WP_RPG7") then 
		local rocket_section = ltx:r_string_ex(wpn_section,"rocket_class")
		return rocket_section and ltx:r_float_ex(rocket_section,"blast") or 0
	end
	
	if (param == "hit_power") then
		local t = parse_names(ltx:r_string_ex(wpn_section,"hit_power") or "")
		local gd = level.get_game_difficulty()+1
		res = tonumber(t[gd] or t[1]) or 0
	else 
		res = ltx:r_float_ex(wpn_section, param) or param == "control_inertion_factor" and 1 or 0
	end 
	
	if (upgr_sections and upgr_sections ~= "") then
		local upgrades = parse_names(upgr_sections)
		for i, sect in ipairs(upgrades) do
			if param == "hit_power" then
				local t = parse_names(ltx:r_string_ex(sect,param) or "")
				res = res + (tonumber(t[gd] or t[1]) or 0)
			else
				res = res + (ltx:r_float_ex(sect,param) or 0)
			end		
		end 
	end
	
	if (param == "hit_power") then
		local ammo_section = parse_names(ltx:r_string_ex(wpn_section,"ammo_class") or "")[1] or ""
		local k_hit = ltx:r_float_ex(ammo_section,"k_hit",0.5)
		res = (res * k_hit) * ltx:r_float_ex(ammo_section,"buck_shot",1)
	end 
	
    return res
end

function GetRPM(wpn_section, upgr_sections) --' скорострельность
	local rpm = read_float(wpn_section, upgr_sections, "rpm")
	return normalize(rpm, 0, 1000)
end

local max_hit_power_value
function GetDamage(wpn_section, upgr_sections) --' повреждение
	local hit_power = read_float(wpn_section, upgr_sections, "hit_power")
   
	if not (max_hit_power_value) then 
		calculate_max_hit_power_value()
	end
	--printf("hit_power=%s max_hit_power_value=%s",hit_power,max_hit_power_value)
	return normalize(hit_power, 0, max_hit_power_value)
end

function GetDamageMP(wpn_section, upgr_sections) -- ??? (повреждениеMP)
	local hit_power = read_float(wpn_section, upgr_sections, "hit_power")
	hit_power = hit_power * 100	
	-- if val < 1.05 then
		-- val = val*100-30
	-- else
		-- val = 75 + math.pow(val/4,2)*25
	-- end	
	return normalizeMP(hit_power)	
end

function GetHandling(wpn_section, upgr_sections) --' удобность
	local PDM_disp_base = read_float(wpn_section, upgr_sections, "PDM_disp_base")
	local control_inertion_factor = read_float(wpn_section, upgr_sections, "control_inertion_factor")
	return (normalize(PDM_disp_base, 2.1, 0) + normalize(control_inertion_factor, 3, 1))/2
end

function GetAccuracy(wpn_section, upgr_sections) --' точность
    local fire_dispersion_base	= read_float(wpn_section, upgr_sections, "fire_dispersion_base")
	return normalize(fire_dispersion_base, 1.5, 0)
end

function calculate_max_hit_power_value()
	local sections_by_hit_power_value = DEV_DEBUG_DEV and {} or nil
	max_hit_power_value = 0
	local gd = level.get_game_difficulty()+1
	local ini = system_ini()
	ini:section_for_each(function(section)
		if (ini:line_exist(section,"hit_power") and ini:line_exist(section,"ammo_class") and ini:line_exist(section,"hud")) then
			local class = ini:r_string_ex(section,"class")
			if (class ~= "WP_RPG7" and class ~= "WP_RG6" and class ~= "W_MOUNTD" and class ~= "W_STMGUN" and class ~= "WP_BINOC" and class ~= "WP_KNIFE") then
				local t = parse_names(ini:r_string_ex(section,"hit_power") or "")

				local hit_power = GetMaxPotential(section,"hit_power")
		
				if (DEV_DEBUG_DEV) then
					sections_by_hit_power_value[section] = hit_power
				end
				
				if (hit_power > max_hit_power_value) then 
					max_hit_power_value = hit_power
				end
			end
		end
	end)
	
	-- List of all weapons and their calculated hit_power values
	if (DEV_DEBUG_DEV) then
		local cfg,err = io.open("weapons_hit_power.ltx","w+")
		if not (err) then
			local function addTab(s,n)
				local padding = {}
				local l = string.len(s)
				for i=1,n-l do 
					padding[#padding+1] = " "
				end 
				return s .. table.concat(padding)
			end
	
			for k,v in spairs(sections_by_hit_power_value, function(t,a,b) return t[a] < t[b] end) do 
				cfg:write(addTab(k,40).." = " .. v .. " | " .. string.format("%.2f",normalize(v,0,max_hit_power_value)) .. "% of max\n")
			end
			cfg:close()
			printf("successfully created weapons_hit_power.ltx")
		end
	end
end

function get_all_upgrade_sections(wpn_section)
	local ini = system_ini()
	
	local stack = ini:r_list(wpn_section,"upgrades")
	if not (stack) then
		return ""
	end 
	
	local t = {}
	local deepest
	while not deepest do
		if (node) then
			local elements = ini:r_list(node,"elements")
			if (elements) then 
				for i,element in ipairs(elements) do 
					local upgr_sect = ini:r_string_ex(element,"section","")
					if (upgr_sect ~= "") then 
						table.insert(t,upgr_sect)
					end
					local next_sect = ini:r_string_ex(element,"effects","")
					if (next_sect ~= "") then 
						table.insert(stack,next_sect)
					end
				end
			end
		end
		if (#stack > 0) then
			node = stack[#stack]
			stack[#stack] = nil
		else
			deepest = true
		end
	end
	
	local str = table.concat(t,",")
	return str
end 

function GetMaxPotential(wpn_section,prop)
	local upgr_sections = get_all_upgrade_sections(wpn_section)
	local total = read_float(wpn_section, upgr_sections, prop)
	return total
end