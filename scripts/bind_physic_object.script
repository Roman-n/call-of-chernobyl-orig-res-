---------------------------------------------------------------------------------------------------
-- Physic objects binding
----------------------------------------------------------------------------------------------------

function init(obj)
	local ini = obj:spawn_ini()
	if not (ini and ini:section_exist("logic")) then
		if obj:clsid() ~= clsid.inventory_box then
			return
		end
	end

	local new_binder = generic_physics_binder(obj)
	obj:bind_object(new_binder)
end

---------------------------------------------------------------------------------------------
class "generic_physics_binder" (object_binder)
function generic_physics_binder:__init(obj) super(obj)
	self.initialized = false
	self.loaded = false
	db.storage[obj:id()] = {}
end

function generic_physics_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_physics_binder:reinit()
	object_binder.reinit(self)
	db.storage[self.object:id()] = db.storage[self.object:id()] or {}
	self.st = db.storage[self.object:id()]
end

function generic_physics_binder:update(delta)
	object_binder.update(self, delta)

	if not self.initialized and db.actor then
		self.initialized = true
		xr_logic.initialize_obj(self.object, self.st, self.loaded, db.actor, modules.stype_item)
	end

	if self.st.active_section ~= nil or (self.object:spawn_ini() ~= nil and self.object:spawn_ini():section_exist("drop_box") == true) then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
	end
	
	self.object:set_callback(callback.hit, generic_physics_binder.hit_callback, self)
	self.object:set_callback(callback.death, generic_physics_binder.death_callback, self)
	self.object:set_callback(callback.use_object, generic_physics_binder.use_callback, self)
	
	xr_sound.update(self.object:id())
end

function generic_physics_binder:net_spawn(data)
	if not object_binder.net_spawn(self, data) then
		return false
	end
	if(self.object:spawn_ini()) then
		--  CoC uses axr_treasure_manager.script instead to generate loot
		if(self.object:spawn_ini():section_exist("drop_box")) then
			--if (coc_treasure_manager.caches[self.object:id()] ~= nil) then
				self.box_items = xr_box.ph_item_box(self.object)
			--end
		end

		if(self.object:spawn_ini():section_exist("level_spot")) then
			if(self.object:spawn_ini():line_exist("level_spot", "actor_box")) then
    	        level.map_add_object_spot(self.object:id(), "ui_pda2_actor_box_location", "st_ui_pda_actor_box")
			end
		end
	end
	
	db.add_obj(self.object)
	
	return true
end

function generic_physics_binder:net_destroy()
    if level.map_has_object_spot(self.object:id(), "ui_pda2_actor_box_location") ~= 0 then
        level.map_remove_object_spot(self.object:id(), "ui_pda2_actor_box_location")
    end
	xr_sound.stop_sounds_by_id(self.object:id())
	local st = db.storage[self.object:id()]
	if st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end
	local on_offline_condlist = db.storage[self.object:id()] and db.storage[self.object:id()].overrides and db.storage[self.object:id()].overrides.on_offline_condlist
	if on_offline_condlist ~= nil then
		xr_logic.pick_section_from_condlist(db.actor, self.object, on_offline_condlist)
	end
	if self.particle ~= nil then
		self.particle:stop()
	end
	db.del_obj(self.object)

	self.object:set_callback(callback.hit, nil)
	self.object:set_callback(callback.death, nil)
	self.object:set_callback(callback.use_object, nil)

	--db.storage[self.object:id()] = nil

	object_binder.net_destroy(self)
end

function generic_physics_binder:net_save_relevant()
	return true
end

function generic_physics_binder:save(packet)
	object_binder.save(self, packet)
	set_save_marker(packet, "save", false, "physics_binder")
	xr_logic.save_obj(self.object, packet)
	set_save_marker(packet, "save", true, "physics_binder")
end

function generic_physics_binder:load(reader)
	self.loaded = true
	object_binder.load(self, reader)
	set_save_marker(reader, "load", false, "physics_binder")
	xr_logic.load_obj(self.object, reader)
	set_save_marker(reader, "load", true, "physics_binder")
end

function generic_physics_binder:use_callback(obj, who)
--	if obj:clsid() == clsid.inventory_box_s then
--		local box_name = obj:name()
--		treasure_manager.use_box(obj, who)
--	end
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "use_callback", obj, who)
	end
	-- Alundaio
	SendScriptCallback("physic_object_on_use_callback",self.object,who)
	-- Alundaio
end

function generic_physics_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	if self.st.ph_on_hit then
		xr_logic.issue_event(self.object, self.st.ph_on_hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	--Alundaio
	SendScriptCallback("physic_object_on_hit_callback",obj, amount, local_direction, who, bone_index)
	--Alundaio
end

function generic_physics_binder:death_callback(victim, who)
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end

	if self.particle ~= nil then
		self.particle:stop()
	end

	if (self.object:spawn_ini() ~= nil and self.object:spawn_ini():section_exist("drop_box") == true and self.box_items) then
		--if (coc_treasure_manager.caches[self.object:id()] == true) then
		--	coc_treasure_manager.caches[self.object:id()] = nil
			self.box_items:spawn_items()
		--	level.map_remove_object_spot(self.object:id(), "treasure")
		--end
	end
end
